(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const Parser = require("binary-parser").Parser;

const
	BHD_VERSION_BABYZ = 14,
	BHD_VERSION_PETZ = 15;

const
	BHDHeader = new Parser()
		.endianess("little")
		.uint16("framesOffset")
		.uint16("unknown")
		.uint16("version")
		.uint16("numBalls")
		.array("unknown2", {
			type: "uint8",
			length: 30
		})
		.array("ballSizes", {
			type: "uint16le",
			length: "numBalls"
		})
		
		.array("unknown3", {
			type: "uint8",
			length: function() {
				// Babyz has an additional block of data we'll skip
				return this.version === 14 /* BHD_VERSION_BABYZ */ ? 160 : 0;
			}
		})
		
		.uint16("animationCount")
		.array("animationEndOffset", {
			type: "uint16le",
			length: "animationCount"
		}),
	
	BHTHeader = new Parser()
		.endianess("little")
		.uint32("fileLength")
		.uint16("version")
		.string("copyright", {
			zeroTerminated: true
		}),
	
	BHTBallPosition = new Parser()
		.endianess("little")
		.int16("x")
		.int16("y")
		.int16("z")
		.uint16("q1") //Ball size delta? Fuzz value? Who knows?
		.uint16("q2");

	BHTFrameHeader = numBalls => new Parser()
		.endianess("little")
		.int16("minx")
		.int16("miny")
		.int16("minz")
		.int16("maxx")
		.int16("maxy")
		.int16("maxz")
		.uint16("tag")
		.array("balls", {
			type: BHTBallPosition,
			length: numBalls
		});

class PetzBHT {
	constructor(bhd, animIndex, bhtRaw) {
		this.frames = [];
		
		let
			decoder = BHTFrameHeader(bhd.numBalls);
		
		for (let frameOffset of bhd.animationFrameOffsets[animIndex]) {
			this.frames.push(decoder.parse(bhtRaw.slice(frameOffset)));
		}
	}
}

class PetzBHD {
	constructor(bhdRaw) {
		const
			header = BHDHeader.parse(bhdRaw),
			frameData = bhdRaw.slice(header.framesOffset);
		
		// Bring the decoded fields of the header out as fields of this object
		for (let fieldName in header) {
			if (header.hasOwnProperty(fieldName)) {
				this[fieldName] = header[fieldName];
			}
		}
		
		this.animations = [];
		
		for (let i = 0; i < header.animationCount; i++) {
			let
				animationStartOffset, /* Index into the 4-byte entries */
				animationLength,
				animFrameOffsets;
			
			if (i === 0) {
				animationStartOffset = 0;
			} else {
				animationStartOffset = header.animationEndOffset[i - 1];
			}
			
			animationLength = header.animationEndOffset[i] - animationStartOffset;
			
			animFrameOffsets = new Parser()
				.endianess("little")
				.array("frameOffsets", {
					type: "uint32le",
					length: animationLength
				});
			
			animFrameOffsets = animFrameOffsets.parse(frameData.slice(animationStartOffset * 4));
			
			this.animations.push(animFrameOffsets.frameOffsets);
		}
	}
}

class PetzAnimationDecoder {

	constructor(bhdRaw) {
		let
			parsed = new PetzBHD(bhdRaw);
		
		this.numBalls = parsed.numBalls;
		this.ballSizes = parsed.ballSizes;
		this.animationFrameOffsets = parsed.animations;
		this.animations = [];
	}
	
	addAnimation(animIndex, bhtRaw) {
		this.animations[animIndex] = new PetzBHT(this, animIndex, bhtRaw);
	}
}

module.exports = PetzAnimationDecoder;
},{"binary-parser":4}],2:[function(require,module,exports){
(function (Buffer){
require("buffer"); // Load the Buffer polyfill

const
	AnimationDecoder = require("./animation-decoder"),

	THREE = require("three");

const
	bunnyBHD = Buffer("ZgwOAA8AQwCoPgAATAIAAAAAAAA9/2/+P/M7ARAAawEAAAAAAAAfAB8AWwBmAEMAQwBNAB8AQQABAEIAAQAoACgAJgAmABYAFgAWABYAFgAWAB8AHwBpAFEAUQAQABAAFQAjACMANQA1AB8AHwAtABsAMwAzACoAIgAiAB4AHgAdABsAGgAWABYAFgAWABYAFgAWAAAAAAAKAAoACgAKAAoACgAiACIAKQBGABYAHwA0AIcAqwDOAPEA/AACARYBIQEpAUcBVgFlAXgBhwGoAckB6gEGAiICTAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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","base64"),

	// Have to write these out explicitly so that brfs's static transformation can catch them for us
	BHTs = [
		Buffer("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","base64"),
		Buffer("AjkAAA8AUEZNX1tWNC4wMTVdIChjKSAxOTk5IFRoZSBMZWFybmluZyBDb21wYW55IFByb3BlcnRpZXMsIEluYy4gKEhpIE1vbSwgaW5kZWVkISkAtv/1/rj+SAABAJMABQAuAMf/SgAAAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAJD/QQAAAAAAGgBs/3L/AAAAAOb/bP9y/wAAAAAAAJv/wv8AAAAAAAB3/0//AAAAABQASP+T/wAAAAA8ABj/pv8AAAAA7P9I/5P/AAAAAMT/GP+m/wAAAAAeALD/7P8AAAAA0/+5/+X/AAAAABIAT/9h/wAAAADt/0//Yf8AAAAAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAAAAFv/g/8AAAAAIACS/0UAAAAAAN//kv9FAAAAAAASAE//Vf8AAAAA7f9P/1X/AAAAAAAAdP9p/wAAAAAOAGb/Sv8AAAAA8f9m/0r/AAAAACsAqv8iAAAAAADU/6X/HgAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAH3/pf8AAAAAAABe/0X/AAAAABsAnv+9/wAAAADk/57/vv8AAAAAAABf/1j/AAAAADIA8P9FAAAAAADK/+//NQAAAAAAAAB0/2kAAAAAAAAAXP97AAAAAAAAAD//hQAAAAAAAAAi/30AAAAAAAAADP9oAAAAAAAAAAD/TQAAAAAAKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAAAABt/2L/AAAAAAAAbv9Y/wAAAAA9AFn/Tf8AAAAAQgBv/0n/AAAAADYAgP9R/wAAAADB/1r/Tf8AAAAAu/9w/0n/AAAAAMr/gP9R/wAAAAAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAAC2//T+uP5IAAEAkwAEAC4Ax/9KAAAAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAkP9BAAAAAAAaAGz/cv8AAAAA5v9s/3L/AAAAAAAAm//C/wAAAAAAAHf/T/8AAAAAFABI/5P/AAAAADwAGP+m/wAAAADs/0j/k/8AAAAAxP8Y/6b/AAAAAB4AsP/s/wAAAADT/7n/5f8AAAAAEgBP/2H/AAAAAO3/T/9h/wAAAAAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAAAAW/+D/wAAAAAgAJL/RQAAAAAA3/+S/0UAAAAAABIAT/9V/wAAAADt/0//Vf8AAAAAAAB0/2n/AAAAAA4AZv9K/wAAAADx/2b/Sv8AAAAAKwCq/yIAAAAAANT/pf8eAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAff+l/wAAAAAAAF7/Rf8AAAAAGwCe/73/AAAAAOT/nv++/wAAAAAAAF//WP8AAAAAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHT/aQAAAAAAAABc/3sAAAAAAAAAP/+FAAAAAAAAACL/fQAAAAAAAAAM/2kAAAAAAAAA//5NAAAAAAAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAAAAG3/Yv8AAAAAAABu/1j/AAAAAD0AWf9N/wAAAABCAG7/Sf8AAAAANgCA/1H/AAAAAMH/Wv9N/wAAAAC7/3D/Sf8AAAAAyv+A/1H/AAAAAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAAAALb/8/64/kgAAQCTAAAALgDH/0oAAAAAAM//yP9BAAAAAAAAAJP/AAAAAAAAAACP/0EAAAAAABoAbP9y/wAAAADm/2z/cv8AAAAAAACb/8L/AAAAAAAAd/9P/wAAAAAUAEj/k/8AAAAAOwAY/6b/AAAAAOz/SP+T/wAAAADD/xj/pv8AAAAAHgCw/+z/AAAAANP/uf/l/wAAAAASAE7/Yf8AAAAA7f9P/2H/AAAAABYA9v+7/wAAAAAeAPb/tv8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/of8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAAAABb/4P/AAAAACAAkv9FAAAAAADf/5L/RQAAAAAAEgBP/1X/AAAAAO3/T/9V/wAAAAAAAHT/af8AAAAADgBm/0r/AAAAAPH/Zv9K/wAAAAArAKr/IgAAAAAA1P+l/x4AAAAAADIA8v85AAAAAADK//L/KQAAAAAAAAB9/6X/AAAAAAAAXf9F/wAAAAAbAJ7/vf8AAAAA5P+e/77/AAAAAAAAX/9Z/wAAAAAyAPD/RQAAAAAAyv/v/zUAAAAAAAAAdP9pAAAAAAAAAFv/ewAAAAAAAQA//4UAAQAAAAEAIv99AAEAAAABAAz/aQABAAAAAQD+/k4AAQAAACoA9v8rAAAAAAAyAPb/JgAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FgAAAAAAwv/1/xsAAAAAAAAAbf9i/wAAAAAAAG7/WP8AAAAAPQBZ/03/AAAAAEEAbv9J/wAAAAA2AID/Uf8AAAAAwf9a/03/AAAAALv/cP9J/wAAAADK/4D/Uf8AAAAAHgDw/9X/AAAAAOP/8P/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAAAtv/y/rj+SAABAJMAAAAuAMf/SgAAAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAI//QQAAAAAAGgBs/3L/AAAAAOX/bP9y/wAAAAAAAJv/wv8AAAAAAAB3/0//AAAAABQASP+T/wAAAAA7ABj/pv8AAAAA6/9I/5P/AAAAAMP/GP+m/wAAAAAeALD/7P8AAAAA0/+5/+X/AP8AABIATv9i/wAAAADt/07/Yv8AAAAAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAD//1v/g/8AAAAAIACS/0UAAAAAAN//kf9FAAAAAAASAE7/Vv8AAAAA7f9P/1b/AAAAAAAAdP9p/wAAAAAOAGb/Sv8AAAAA8f9m/0r/AAAAACsAqv8iAAAAAADU/6X/HgAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAH3/pf8AAAAA//9d/0X/AAAAABsAnv+9/wAAAADk/57/vv8A/wAA//9e/1n/AAAAADIA8P9FAAAAAADK/+//NQAAAAAAAABz/2kAAAD/AAAAW/97AAAA/wABAD//hQABAP8AAgAi/30AAgD/AAIAC/9qAAIA/wACAP3+UAACAP8AKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAAAABs/2L/AAAAAAAAbv9Y/wAAAAA9AFn/Tf8AAAAAQQBu/0n/AAAAADYAf/9R/wAAAADB/1r/Tf8AAAAAu/9w/0n/AAAAAMr/gP9R/wAAAAAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAQACAAEAtv/w/rj+SAABAJMAAAAuAMf/SgAAAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAI//QQAAAAAAGQBr/3L/AAAAAOX/bP9y/wAAAAAAAJv/wv8AAAAAAAB3/0//AAAAABQASP+T/wAAAAA7ABf/pv8AAAAA6/9I/5P/AAAAAMP/GP+m/wAAAAAfALD/7P8AAQAA0v+5/+X/AP8AABIATv9i/wAAAADt/07/Yv8AAAAAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAD//1v/g/8AAAAAIACS/0UAAAAAAN//kf9FAAAAAAASAE7/Vv8AAAAA7f9O/1b/AAAAAAAAc/9p/wAAAAAOAGX/Sv8AAAAA8f9m/0r/AAAAACsAqv8iAAAAAADU/6X/HgAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAH3/pf8AAAAA//9d/0X/AAAAABsAnv+9/wABAADk/57/vv8A/wAA//9e/1n/AAAAADIA8P9FAAAAAADK/+//NQAAAAAAAABz/2kAAAD/AAEAW/97AAAA/wACAD//hQACAP8AAwAi/34AAwD/AAMACv9rAAQA/wAEAPv+UQAEAP8AKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAA//9s/2L/AAAAAAAAbv9Y/wAAAAA9AFj/Tf8AAAAAQQBt/0n/AAAAADYAf/9R/wAAAADB/1r/Tf8AAAAAu/9w/0n/AAAAAMr/gP9R/wAAAAAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAQACAAEAtv/v/rj+SAABAJMAAAAuAMf/SwAAAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAI//QQAAAAAAGQBr/3L/AAABAOX/bP9y/wAAAQAAAJv/wv8AAAAAAAB2/0//AAABABMASP+T/wAAAQA6ABf/pv8AAAEA6/9I/5P/AAABAML/Gf+m/wAAAQAfALD/7P8AAQAA0f+5/+T/AP4AABIATv9i/wAAAQDs/07/Yv8AAAEAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAD//1v/g/8AAAEAIACS/0UA/wAAAN//kf9FAAAAAAASAE7/Vv8AAAEA7P9O/1b/AAABAAAAc/9p/wAAAQAOAGX/Sv8AAAEA8f9l/0r/AAABACsAqv8iAAAAAADU/6X/HgAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAH3/pf8AAAEA//9d/0X/AAABABsAnv+9/wABAADj/57/vv8A/gAA//9e/1n/AAABADIA8P9FAAAAAADK/+//NQAAAAAAAABz/2kAAAD+AAEAW/97AAAA/gACAD//hQACAP4AAwAh/34ABAD+AAQACf9sAAUA/gAFAPr+UwAFAP4AKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAA//9s/2P/AAABAP//bf9Y/wAAAQA8AFj/Tf8AAAEAQQBt/0n/AAABADYAfv9R/wAAAQDB/1r/Tf8AAAEAu/9w/0n/AAABAMr/gP9R/wAAAQAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgACAAIABgABALb/7v64/kgAAQCTAAAALgDH/0sAAQAAAM//yP9BAAAAAAAAAJP/AAAAAAAAAACP/0EAAAAAABkAa/9y/wAAAQDl/2z/cv8AAAEAAACb/8L/AAAAAAAAdv9P/wAAAQATAEf/k/8AAAEAOgAX/6b/AAABAOv/SP+T/wAAAQDC/xn/pv8AAAEAHwCw/+z/AAEAANH/uf/k/wD9AAARAE3/Yv8AAAEA7P9O/2L/AAABABYA9v+7/wAAAAAeAPb/tv8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/of8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAA//9b/4T/AAABACAAkv9FAP8AAADf/5H/RQAAAAAAEQBN/1b/AAABAOz/Tv9W/wAAAQD//3P/af8AAAEADQBl/0r/AAABAPH/Zf9K/wAAAQArAKr/IgAAAAAA1P+l/x4AAAAAADIA8v85AAAAAADK//L/KQAAAAAAAAB9/6X/AAABAP//XP9F/wAAAQAbAJ3/vf8AAQAA4/+e/77/AP0AAP//Xv9Z/wAAAQAyAPD/RQAAAAAAyv/v/zUAAAAAAAAAc/9pAAAA/gABAFv/egAAAP4AAwA+/4UAAwD+AAQAIf9+AAUA/gAFAAn/bQAGAP4ABgD5/lQABgD+ACoA9v8rAAAAAAAyAPb/JgAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FgAAAAAAwv/1/xsAAAAAAP//bP9j/wAAAQD//23/WP8AAAEAPABX/03/AAABAEEAbP9J/wAAAQA2AH7/Uf8AAAEAwf9a/03/AAABALv/cP9J/wAAAQDK/4D/Uf8AAAEAHgDw/9X/AAAAAOP/8P/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIAAgADAAYAAQC2/+3+uP5IAAEAkgAAAC4Ax/9LAAEAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAj/9BAAAAAAAZAGv/cv8AAAEA5f9s/3L/AAABAAAAm//C/wAAAAAAAHb/T/8AAAEAEwBH/5P/AAABADoAFv+n/wAAAQDr/0j/k/8AAAEAwv8Z/6f/AAABAB8AsP/s/wABAADQ/7n/5P8A/QAAEQBN/2L/AAABAOz/Tv9i/wAAAQAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAP//Wv+E/wAAAQAgAJH/RQD/AAAA3/+R/0UAAAAAABEATf9W/wAAAQDs/07/Vv8AAAEA//9z/2n/AAABAA0AZP9K/wAAAQDx/2X/Sv8AAAEAKwCq/yIAAAAAANT/pf8eAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAff+l/wAAAQD//1z/Rf8AAAEAGwCd/73/AAEAAOP/nv++/wD9AAD//13/Wf8AAAEAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHP/aQAAAP4AAQBa/3oAAAD+AAMAPv+EAAMA/gAEACH/fgAFAP4ABgAI/20ABwD+AAYA+P5UAAcA/gAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAD//2z/Y/8AAAEA//9t/1j/AAABADwAV/9N/wAAAQBBAGz/Sf8AAAEANgB9/1H/AAABAMD/Wv9N/wAAAQC7/3D/Sf8AAAEAyv+A/1H/AAABAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACAAIAAwAGAAEAtv/t/rj+SAABAJIAAAAuAMf/SwABAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAI//QQD/AAAAGQBq/3L/AAABAOX/bP9y/wAAAQAAAJv/wv8AAAAA//92/1D/AAABABMAR/+T/wAAAQA5ABb/p/8AAAEA6v9I/5P/AAABAMH/Gf+n/wAAAQAfALD/7P8AAQAA0P+5/+P/APwAABEATf9i/wAAAQDs/07/Yv8AAAEAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAD//1r/hP8AAAEAIACR/0UA/wAAAN//kf9FAAAAAAARAE3/Vv8AAAEA7P9O/1b/AAABAP//c/9p/wAAAQANAGT/Sv8AAAEA8f9l/0r/AAABACsAqv8iAAAAAADU/6X/HwAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAHz/pf8AAAEA//9c/0X/AAABABsAnf+9/wABAADj/57/vv8A/AAA//9d/1n/AAABADIA8P9FAAAAAADK/+//NQAAAAAAAABy/2kA/wD+AAEAWv96AAAA/gADAD7/hAADAP4ABAAh/34ABQD+AAUACP9tAAcA/gAGAPj+VAAHAP4AKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAA//9r/2P/AAABAP//bf9Y/wAAAQA8AFb/Tf8AAAEAQQBr/0n/AAABADYAff9R/wAAAQDA/1r/Tf8AAAEAu/9w/0n/AAABAMr/gP9R/wAAAQAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgACAAQABgABALb/7f64/kgAAQCSAAAALgDH/0sAAQAAAM//yP9BAAAAAAAAAJP/AAAAAAAAAACP/0EA/wAAABkAav9y/wAAAQDl/2z/cv8AAAEAAACb/8L/AAAAAP//dv9Q/wAAAQATAEf/lP8AAAEAOQAW/6f/AAABAOr/SP+U/wAAAQDB/xn/p/8AAAEAIACw/+z/AAEAAND/uf/j/wD8AAARAE3/Yv8AAAEA7P9O/2L/AAABABYA9v+7/wAAAAAeAPb/tv8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/of8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAA//9a/4T/AAABACAAkf9FAP8AAADf/5H/RQAAAAAAEQBN/1b/AAABAOz/Tv9W/wAAAQD//3L/af8AAAEADQBk/0r/AAABAPH/Zf9K/wAAAQArAKr/IgAAAAAA1P+k/x8AAAAAADIA8v85AAAAAADK//L/KQAAAAAAAAB8/6X/AAABAP//XP9F/wAAAQAbAJ3/vf8AAQAA4/+e/77/APwAAP//Xf9Z/wAAAQAyAPD/RQAAAAAAyv/v/zUAAAAAAAAAcv9pAP8A/gABAFr/egAAAP4AAwA+/4QAAgD+AAQAIf99AAUA/gAFAAj/bAAGAP4ABgD4/lMABgD+ACoA9v8rAAAAAAAyAPb/JgAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FgAAAAAAwv/1/xsAAAAAAP//a/9j/wAAAQD//23/WP8AAAEAPABW/03/AAABAEEAa/9J/wAAAQA2AH3/Uf8AAAEAwP9a/03/AAABALv/cP9J/wAAAQDK/4D/Uf8AAAEAHgDw/9X/AAAAAOP/8P/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIAAgAEAAYAAgC2/+3+uP5IAAEAkgAAAC4Ax/9LAAEAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAj/9BAP8AAAAZAGr/cv8AAAEA5f9s/3L/AAABAAAAm//C/wAAAAD//3X/UP8AAAEAEwBH/5T/AAABADkAFv+n/wAAAQDq/0j/lP8AAAEAwf8Z/6f/AAABACAAsP/s/wABAADQ/7n/4/8A/AAAEQBN/2L/AAABAOz/Tv9i/wAAAQAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAP//Wv+E/wAAAQAgAJH/RQD/AAAA3/+R/0UAAAAAABEATf9W/wAAAQDs/07/Vv8AAAEA//9y/2n/AAABAA0AZP9K/wAAAQDx/2X/Sv8AAAEAKwCq/yIAAAAAANT/pP8fAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAfP+l/wAAAQD//1z/Rf8AAAEAGwCd/73/AAH/AOP/nv++/wD8AAD//13/Wf8AAAEAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHL/aQD/AP4AAQBa/3oAAAD+AAIAPv+EAAIA/gAEACH/fQAEAP4ABQAJ/2sABgD+AAYA+P5SAAYA/gAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAD//2v/Y/8AAAEA//9t/1j/AAABADwAVv9N/wAAAQBBAGv/Sf8AAAEANgB9/1H/AAABAMD/Wv9N/wAAAQC7/3D/Sf8AAAEAyv+A/1H/AAABAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACAAIABAAGAAIAtv/u/rj+SAABAJIAAAAuAMf/SwABAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAI//QQD/AAAAGQBq/3L/AAABAOX/bP9y/wAAAQAAAJv/wv8AAAAA//92/1D/AAABABMAR/+U/wAAAQA5ABb/p/8AAAEA6v9I/5T/AAABAMH/Gf+n/wAAAQAgALD/7P8AAQAA0P+5/+P/APwAABEATf9i/wAAAQDs/07/Yv8AAAEAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAD//1r/hP8AAAEAIACR/0UA/wAAAN//kf9FAAAAAAARAE3/Vv8AAAEA7P9O/1b/AAABAP//cv9p/wAAAQANAGT/Sv8AAAEA8f9l/0r/AAABACsAqv8iAAAAAADU/6T/HwAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAHz/pf8AAAEA//9c/0X/AAABABsAnf+9/wABAADj/57/vv8A/AAA//9d/1n/AAABADIA8P9FAAAAAADK/+//NQAAAAAAAABy/2kA/wD+AAEAWv96AAAA/gACAD7/hAABAP4AAwAh/30AAwD+AAQACf9qAAUA/gAFAPn+UQAFAP4AKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAA//9r/2P/AAABAP//bf9Y/wAAAQA8AFb/Tf8AAAEAQQBr/0n/AAABADYAff9R/wAAAQDA/1r/Tf8AAAEAu/9w/0n/AAABAMr/gP9R/wAAAQAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgACAAQABgACALb/8P64/kgAAQCSAAAALgDH/0sAAQAAAM//yP9BAAAAAAAAAJP/AAAAAAAAAACP/0EA/wAAABkAav9y/wAAAQDl/2z/cv8AAAEAAACb/8L/AAAAAP//dv9Q/wAAAQATAEf/k/8AAAEAOQAW/6f/AAABAOr/SP+T/wAAAQDB/xn/p/8AAAEAHwCw/+z/AAEAAND/uf/j/wD8AAARAE3/Yv8AAAEA7P9O/2L/AAABABYA9v+7/wAAAAAeAPb/tv8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/of8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAA//9a/4T/AAABACAAkf9FAP8AAADf/5H/RQAAAAAAEQBN/1b/AAABAOz/Tv9W/wAAAQD//3P/af8AAAEADQBk/0r/AAABAPH/Zf9K/wAAAQArAKr/IgAAAAAA1P+l/x8AAAAAADIA8v85AAAAAADK//L/KQAAAAAAAAB8/6X/AAABAP//XP9F/wAAAQAbAJ3/vf8AAQAA4/+e/77/APwAAP//Xf9Z/wAAAQAyAPD/RQAAAAAAyv/v/zUAAAAAAAAAcv9pAP8A/wABAFr/egAAAP8AAgA+/4QAAQD/AAMAIf98AAMA/wAEAAn/agAEAP8ABAD7/lAABAD/ACoA9v8rAAAAAAAyAPb/JgAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FgAAAAAAwv/1/xsAAAAAAP//a/9j/wAAAQD//23/WP8AAAEAPABW/03/AAABAEEAa/9J/wAAAQA2AH3/Uf8AAAEAwP9a/03/AAABALv/cP9J/wAAAQDK/4D/Uf8AAAEAHgDw/9X/AAAAAOP/8P/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIAAgAEAAYAAQC2//H+uP5IAAEAkgAAAC4Ax/9LAAEAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAj/9BAAAAAAAZAGv/cv8AAAEA5f9s/3L/AAABAAAAm//C/wAAAAAAAHb/T/8AAAEAEwBH/5P/AAABADoAFv+n/wAAAQDr/0j/k/8AAAEAwv8Z/6f/AAABAB8AsP/s/wABAADQ/7n/5P8A/QAAEQBN/2L/AAABAOz/Tv9i/wAAAQAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAP//Wv+E/wAAAQAgAJH/RQD/AAAA3/+R/0UAAAAAABEATf9W/wAAAQDs/07/Vv8AAAEA//9z/2n/AAABAA0AZP9K/wAAAQDx/2X/Sv8AAAEAKwCq/yIAAAAAANT/pf8eAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAff+l/wAAAQD//1z/Rf8AAAEAGwCd/73/AAEAAOP/nv++/wD9AAD//13/Wf8AAAEAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHP/aQAAAP8AAQBa/3oAAAD/AAIAPv+EAAEA/wACACH/fAACAP8AAwAK/2kAAwD/AAMA/P5PAAMA/wAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAD//2z/Y/8AAAEA//9t/1j/AAABADwAV/9N/wAAAQBBAGz/Sf8AAAEANgB9/1H/AAABAMD/Wv9N/wAAAQC7/3D/Sf8AAAEAyv+A/1H/AAABAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACAAIAAwAGAAEAtv/y/rj+SAABAJIAAAAuAMf/SwABAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAI//QQAAAAAAGQBr/3L/AAABAOX/bP9y/wAAAQAAAJv/wv8AAAAAAAB2/0//AAABABMAR/+T/wAAAQA6ABf/pv8AAAEA6/9I/5P/AAABAML/Gf+m/wAAAQAfALD/7P8AAQAA0f+5/+T/AP0AABEATf9i/wAAAQDs/07/Yv8AAAEAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAD//1v/hP8AAAEAIACS/0UA/wAAAN//kf9FAAAAAAARAE3/Vv8AAAEA7P9O/1b/AAABAP//c/9p/wAAAQANAGX/Sv8AAAEA8f9l/0r/AAABACsAqv8iAAAAAADU/6X/HgAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAH3/pf8AAAEA//9c/0X/AAABABsAnf+9/wABAADj/57/vv8A/QAA//9e/1n/AAABADIA8P9FAAAAAADK/+//NQAAAAAAAABz/2kAAAD/AAEAW/96AAAA/wABAD7/hAAAAP8AAgAh/3wAAQD/AAIAC/9oAAIA/wADAP3+TgACAP8AKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAA//9s/2P/AAABAP//bf9Y/wAAAQA8AFf/Tf8AAAEAQQBs/0n/AAABADYAfv9R/wAAAQDB/1r/Tf8AAAEAu/9w/0n/AAABAMr/gP9R/wAAAQAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgACAAMABgABALb/8/64/kgAAQCSAAAALgDH/0sAAAAAAM//yP9BAAAAAAAAAJP/AAAAAAAAAACP/0EAAAAAABkAa/9y/wAAAQDl/2z/cv8AAAEAAACb/8L/AAAAAAAAdv9P/wAAAQATAEj/k/8AAAEAOgAX/6b/AAABAOv/SP+T/wAAAQDC/xn/pv8AAAEAHwCw/+z/AAEAANH/uf/k/wD+AAASAE7/Yv8AAAEA7P9O/2L/AAABABYA9v+7/wAAAAAeAPb/tv8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/of8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAA//9b/4P/AAABACAAkv9FAP8AAADf/5H/RQAAAAAAEgBO/1b/AAABAOz/Tv9W/wAAAQAAAHP/af8AAAEADgBl/0r/AAABAPH/Zf9K/wAAAQArAKr/IgAAAAAA1P+l/x4AAAAAADIA8v85AAAAAADK//L/KQAAAAAAAAB9/6X/AAABAP//Xf9F/wAAAQAbAJ7/vf8AAQAA4/+e/77/AP4AAP//Xv9Z/wAAAQAyAPD/RQAAAAAAyv/v/zUAAAAAAAAAc/9pAAAA/wAAAFv/ewAAAP8AAQA+/4QAAAD/AAEAIv98AAEA/wACAAv/aAABAP8AAgD+/k0AAQD/ACoA9v8rAAAAAAAyAPb/JgAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FgAAAAAAwv/1/xsAAAAAAP//bP9j/wAAAQD//23/WP8AAAEAPABY/03/AAABAEEAbf9J/wAAAQA2AH7/Uf8AAAEAwf9a/03/AAABALv/cP9J/wAAAQDK/4D/Uf8AAAEAHgDw/9X/AAAAAOP/8P/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIAAgACAAYAAQC2//T+uP5IAAEAkgAAAC4Ax/9KAAAAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAj/9BAAAAAAAZAGv/cv8AAAAA5f9s/3L/AAAAAAAAm//C/wAAAAAAAHf/T/8AAAAAFABI/5P/AAAAADsAF/+m/wAAAADr/0j/k/8AAAAAw/8Y/6b/AAAAAB8AsP/s/wABAADS/7n/5f8A/wAAEgBO/2L/AAAAAO3/Tv9i/wAAAAAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAP//W/+D/wAAAAAgAJL/RQAAAAAA3/+R/0UAAAAAABIATv9W/wAAAADt/07/Vv8AAAAAAABz/2n/AAAAAA4AZf9K/wAAAADx/2b/Sv8AAAAAKwCq/yIAAAAAANT/pf8eAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAff+l/wAAAAD//13/Rf8AAAAAGwCe/73/AAEAAOT/nv++/wD/AAD//17/Wf8AAAAAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHP/aQAAAAAAAABb/3sAAAAAAAEAP/+EAAAAAAABACL/fAAAAAAAAQAM/2gAAAAAAAEA//5NAAAAAAAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAD//2z/Yv8AAAAAAABu/1j/AAAAAD0AWP9N/wAAAABBAG3/Sf8AAAAANgB//1H/AAAAAMH/Wv9N/wAAAAC7/3D/Sf8AAAAAyv+A/1H/AAAAAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAABAAIAAQC2//T+uP5IAAEAkwAAAC4Ax/9KAAAAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAj/9BAAAAAAAaAGz/cv8AAAAA5f9s/3L/AAAAAAAAm//C/wAAAAAAAHf/T/8AAAAAFABI/5P/AAAAADsAGP+m/wAAAADr/0j/k/8AAAAAw/8Y/6b/AAAAAB4AsP/s/wAAAADT/7n/5f8A/wAAEgBO/2L/AAAAAO3/Tv9i/wAAAAAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAP//W/+D/wAAAAAgAJL/RQAAAAAA3/+R/0UAAAAAABIATv9W/wAAAADt/0//Vv8AAAAAAAB0/2n/AAAAAA4AZv9K/wAAAADx/2b/Sv8AAAAAKwCq/yIAAAAAANT/pf8eAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAff+l/wAAAAD//13/Rf8AAAAAGwCe/73/AAAAAOT/nv++/wD/AAD//17/Wf8AAAAAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHP/aQAAAAAAAABb/3sAAAAAAAAAP/+FAAAAAAABACL/fAAAAAAAAQAM/2gAAAAAAAEA//5NAAAAAAAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAAAAGz/Yv8AAAAAAABu/1j/AAAAAD0AWf9N/wAAAABBAG7/Sf8AAAAANgB//1H/AAAAAMH/Wv9N/wAAAAC7/3D/Sf8AAAAAyv+A/1H/AAAAAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAABAAIAAQC2//X+uP5IAAEAkwAEAC4Ax/9KAAAAAADP/8j/QQAAAAAAAACT/wAAAAAAAAAAj/9BAAAAAAAaAGz/cv8AAAAA5v9s/3L/AAAAAAAAm//C/wAAAAAAAHf/T/8AAAAAFABI/5P/AAAAADsAGP+m/wAAAADs/0j/k/8AAAAAw/8Y/6b/AAAAAB4AsP/s/wAAAADT/7n/5f8AAAAAEgBO/2H/AAAAAO3/T/9h/wAAAAAWAPb/u/8AAAAAHgD2/7b/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6H/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAAAAW/+D/wAAAAAgAJL/RQAAAAAA3/+S/0UAAAAAABIAT/9V/wAAAADt/0//Vf8AAAAAAAB0/2n/AAAAAA4AZv9K/wAAAADx/2b/Sv8AAAAAKwCq/yIAAAAAANT/pf8eAAAAAAAyAPL/OQAAAAAAyv/y/ykAAAAAAAAAff+l/wAAAAAAAF3/Rf8AAAAAGwCe/73/AAAAAOT/nv++/wAAAAAAAF//Wf8AAAAAMgDw/0UAAAAAAMr/7/81AAAAAAAAAHT/aQAAAAAAAABb/3sAAAAAAAAAP/+FAAAAAAAAACL/fAAAAAAAAAAM/2gAAAAAAAAAAP9NAAAAAAAqAPb/KwAAAAAAMgD2/yYAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xYAAAAAAML/9f8bAAAAAAAAAG3/Yv8AAAAAAABu/1j/AAAAAD0AWf9N/wAAAABBAG7/Sf8AAAAANgCA/1H/AAAAAMH/Wv9N/wAAAAC7/3D/Sf8AAAAAyv+A/1H/AAAAAB4A8P/V/wAAAADj//D/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAAAALb/9f64/kgAAQCTAAQALgDH/0oAAAAAAM//yP9BAAAAAAAAAJP/AAAAAAAAAACQ/0EAAAAAABoAbP9y/wAAAADm/2z/cv8AAAAAAACb/8L/AAAAAAAAd/9P/wAAAAAUAEj/k/8AAAAAPAAY/6b/AAAAAOz/SP+T/wAAAADE/xj/pv8AAAAAHgCw/+z/AAAAANP/uf/l/wAAAAASAE//Yf8AAAAA7f9P/2H/AAAAABYA9v+7/wAAAAAeAPb/tv8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/of8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAAAABb/4P/AAAAACAAkv9FAAAAAADf/5L/RQAAAAAAEgBP/1X/AAAAAO3/T/9V/wAAAAAAAHT/af8AAAAADgBm/0r/AAAAAPH/Zv9K/wAAAAArAKr/IgAAAAAA1P+l/x4AAAAAADIA8v85AAAAAADK//L/KQAAAAAAAAB9/6X/AAAAAAAAXv9F/wAAAAAbAJ7/vf8AAAAA5P+e/77/AAAAAAAAX/9Y/wAAAAAyAPD/RQAAAAAAyv/v/zUAAAAAAAAAdP9pAAAAAAAAAFz/ewAAAAAAAAA//4UAAAAAAAAAIv99AAAAAAAAAAz/aAAAAAAAAAAA/00AAAAAACoA9v8rAAAAAAAyAPb/JgAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FgAAAAAAwv/1/xsAAAAAAAAAbf9i/wAAAAAAAG7/WP8AAAAAPQBZ/03/AAAAAEIAbv9J/wAAAAA2AID/Uf8AAAAAwf9a/03/AAAAALv/cP9J/wAAAADK/4D/Uf8AAAAAHgDw/9X/AAAAAOP/8P/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAAAtv/1/rj+SAABAJMABgAuAMf/SgAAAAAAz//I/0EAAAAAAAAAk/8AAAAAAAAAAJD/QQAAAAAAGgBs/3L/AAAAAOb/bP9y/wAAAAAAAJv/wv8AAAAAAAB3/0//AAAAABQASP+T/wAAAAA8ABj/pv8AAAAA7P9I/5P/AAAAAMT/GP+m/wAAAAAeALD/7P8AAAAA0/+5/+X/AAAAABIAT/9h/wAAAADt/0//Yf8AAAAAFgD2/7v/AAAAAB4A9v+2/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+h/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAAAAFv/g/8AAAAAIACS/0UAAAAAAN//kv9FAAAAAAASAE//Vf8AAAAA7f9P/1X/AAAAAAAAdP9p/wAAAAAOAGb/Sv8AAAAA8f9m/0r/AAAAACsAqv8iAAAAAADU/6X/HgAAAAAAMgDy/zkAAAAAAMr/8v8pAAAAAAAAAH3/pf8AAAAAAABe/0X/AAAAABsAnv+9/wAAAADk/57/vv8AAAAAAABf/1j/AAAAADIA8P9FAAAAAADK/+//NQAAAAAAAAB0/2kAAAAAAAAAXP97AAAAAAAAAD//hQAAAAAAAAAi/30AAAAAAAAADP9oAAAAAAAAAAD/TQAAAAAAKgD2/ysAAAAAADIA9v8mAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8WAAAAAADC//X/GwAAAAAAAABt/2L/AAAAAAAAbv9Y/wAAAAA9AFn/Tf8AAAAAQgBv/0n/AAAAADYAgP9R/wAAAADB/1r/Tf8AAAAAu/9w/0n/AAAAAMr/gP9R/wAAAAAeAPD/1f8AAAAA4//w/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAAA=","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("jDYAAA8AUEZNX1tWNC4wMTVdIChjKSAxOTk5IFRoZSBMZWFybmluZyBDb21wYW55IFByb3BlcnRpZXMsIEluYy4gKEhpIE1vbSwgaW5kZWVkISkAs//u/rj+SwACAI8AAQAsAMn/TAAC+wEA0//R/04AEAT+AAAAk//u//8AAAAAAJ3/NAADAAAAGgDD/2D/2AAAAOb/w/9g/9gAAAAAAKv/sv/kAAAAAADt/2f/uQAAABUAmP9T/wAAAAA8AGj/Zv8AAAAA7P+Z/1T/C/r+AMT/a/9t/wv6/gAqAK//4f/5CvwA0/+3/+D//AECABMAxf89/9gAAADt/8X/Pf/YAAAAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAALD/Wv/YAAAAIQCh/zkA+voAAN7/ov85APIIAwATAND/Nv/YAAAA7f/Q/zb/2AAAAAAA0/9f/7kAAAAOAOL/P//gAAAA8v/i/z//4AAAADEAvv8bAO/6/wDN/8H/HwDtCAQAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAKf/iP/YAAAAAADf/zX/4AAAABwAsf+x/+4L/gDk/7H/sf/tAf0AAADS/0T/4AAAADIA8f9FAAAAAADK//D/NQAAAAAAAACE/18A/f8EAP7/a/9vAAgBBQD6/1H/fgARAPwA/f8z/4IAHAAAAP3/Ff+AACMA/gD9//n+eAAjAP4AKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAADe/1b/uQAAAAAA8f9Z/7kAAAA9ANf/OP/gAAAAQgDp/0T/4AAAADYA7/9W/+AAAADC/9f/OP/gAAAAu//p/0X/4AAAAMr/7/9W/+AAAAAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALb/8f64/kkAAgCWAAAALQDI/0wAAQABAND/0P9PABD//wAAAJb/7v//AAAAAACf/zQAAwAAABoAtv9b/+IAAQDm/7f/XP/iAAEAAACo/7L/6QAAAAEA3/9T/8z/AQAUAIn/Wf8AAQEAOwBY/2v/AAEBAOz/iv9a/wv8/QDF/13/dv8L/P0AKwCu/9//+Ar8ANT/tf/f//sCAQASALD/OP/iAAEA7f+w/zn/4gABABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACi/1r/4gABACEAo/86APr/AQDf/6T/OwDxBAAAEgC4/y//4gABAO3/uP8w/+IAAQABAMb/V//M/wEADgDN/zT/6AABAPL/zv81/+gAAQAtAMD/GgDt/gAA0P/D/x8A6gUBADIA8/85AAAAAADK//L/KQAAAAAAAACi/4r/3wAAAAAAyf8s/+gAAQAcAK7/sP/wC/4A5P+u/7D/7wH+AAAAv/88/+gAAQAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAhv9fAAIAAQD//2//cgAJAP8AAABV/4IAE/76AAQAOP+HACH+/wAGABr/iQAt/v8ACAD8/ocALf7/ACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAAAy/9J/8z/AQABANr/Rv/M/wEAPQDA/y7/6AABAEIA1P83/+gAAQA3AN7/SP/oAAEAwf/D/zH/6AABALz/1/86/+gAAQDL/+D/Sv/oAAEAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAC3//r+uP5IAAIAowAAAC4Ax/9LAAAEAQDN/9D/UAAQ+gAAAACa/+7/AAAAAAAAov81AAIAAAAbAKf/WP/tAAMA5/+p/1n/7QADAAAApv+x/+4AAAACAMj/Qf/iAAMAEwB8/2L/AAECADkASv90/wABAgDr/37/ZP8L/v0Axv9R/4H/C/79ACsArv/e//gL/ADV/7T/3f/6AgEAEgCX/zj/7QADAOz/mf85/+0AAwAWAPf/u/8AAAAAHgD3/7b/AAAAACUA9/+8/wAAAADq//f/p/8AAAAA4//3/6H/AAAAANv/9/+m/wAAAAAeAPP/yf8AAAAA4//z/7T/AAAAAAAAlf9d/+0AAwAgAKb/OwD7BAEA3/+n/zwA8AD9ABEAnf8t/+0AAwDs/5//L//tAAMAAQC2/1D/4gADAA4Atf8t//ABAwDy/7b/Lv/wAQMAKADC/xoA6wICANP/x/8fAOcB/gAyAPP/OQAAAAAAyv/y/ykAAAAAAAAAnv+L/+gAAAD//7D/Jv/wAQMAHACr/67/8gv9AOT/q/+u//AC/gAAAKn/OP/wAQMAMgDx/0UAAAAAAMr/8P81AAAAAAAAAIj/XgAIAP8AAAB0/3QAC//5AAUAXP+GABX9+AAMAD//jAAl/P0ADwAi/5EAN/wBABIABf+YADf8AQAqAPf/KwAAAAAAMgD3/yYAAAAAADkA9/8sAAAAAADR//b/HAAAAAAAyv/2/xYAAAAAAML/9v8bAAAAAAABALT/Qv/iAAMAAQC9/zr/4gADADwApv8p//ABAwBCALv/Lf/wAQMAOADI/zz/8AEDAMH/rf8t//ABAwC8/8P/Mv/wAQMAzP/O/z//8AEDAB4A8f/V/wAAAADj//H/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACADcADQA4ABAAt/8F/7j+SAACALAAAAAuAMj/SgD/CAEAy//R/1AAD/YBAAAAnv/u/wEAAAAAAKX/NQACAAAAGwCa/1f/9gEEAOf/n/9Z//YBBAAAAKX/sf/yAAAAAgCy/zn/8wAEABMAc/9r/wECAwA3AED/ff8BAgMA6/92/2z/C//9AMb/Sv+M/wv//QArAK//3f/3C/wA1f+0/93/+QIBABEAhf88//YBBADs/4j/Pf/2AQQAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAAIr/YP/2AQQAIACp/zwA/AgBAN//qv89APD8+wARAIj/MP/2AQQA7P+L/zL/9gEEAAIAqP9N//MABAAOAKD/K//3AQQA8v+j/yz/9wEEACQAxf8ZAOoFBADW/8v/HwDl//sAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAJz/jf/vAAAA//+b/yT/9wEEABwAqf+u//QM/QDk/6r/rv/yAv8AAACX/zj/9wEEADIA8f9FAAAAAADK//D/NQAAAAAAAACL/14ADf/9AAEAev93AA3/8wAKAGP/iAAX/fYAEgBH/5AAKfr7ABcAK/+YAED7AwAaABD/pQBA+wMAKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAQCg/0D/8wAEAAEApf85//MABAA8AJD/Kf/3AQQAQgCl/yn/9wEEADgAtf81//cBBADB/5r/Lf/3AQQAvP+x/y//9wEEAM3/vv85//cBBAAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALf/DP+4/kcAAgC3AAAALgDI/0oA/goBAMr/0P9QAA/0AQAAAJ//7v8BAAAAAACm/zUAAgAAABsAk/9Y//oBBADn/5j/Wf/6AQQAAACk/7H/9AAAAAIAp/84//oBBAATAG7/b/8BAQQANgA7/4H/AQEEAOv/cv9w/wwA/gDG/0f/kf8MAP4AKwCu/93/9wz8ANX/tP/c//gCAAARAHv/P//6AQQA6/9//0D/+gEEABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACF/2L/+gEEAB8Aqv88APwJAQDf/6z/PQDw+/oAEAB9/zP/+gEEAOv/gf80//oBBAACAKH/TP/6AQQADgCW/yv/+gEEAPL/mf8s//oBBAAiAMb/GQDpBgUA1//M/yAA5P75ADIA8/85AAAAAADK//L/KQAAAAAAAACZ/43/8gAAAP//kP8l//oBBAAcAKf/rv/1DP0A5P+o/67/8wL/AP//jv85//oBBAAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAjP9eABD//AACAH3/eAAO//AADABn/4oAGfz0ABUATP+TACz5+wAbADD/nABF+wQAHgAX/6wARfsEACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAEAl/9B//oBBAABAJr/Ov/6AQQAPACF/yr/+gEEAEIAmv8p//oBBAA5AKv/NP/6AQQAwf+R/y7/+gEEAL3/p/8u//oBBADN/7X/N//6AQQAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAC3/wv/uP5HAAIAtgAAAC4AyP9KAP4KAQDK/9D/UAAP8wEAAACf/+7/AQAAAAAApv81AAEAAAAbAJP/V//7AQQA5/+Z/1n/+wEEAAAApP+x//QAAAACAKb/OP/7AQQAEwBu/2//AQIEADYAOv+B/wECBADr/3L/cf8LAP4Axf9H/5D/CwD+ACsArv/d//cM/ADV/7T/3P/4AgEAEAB7/z//+wEEAOv/f/9A//sBBAAWAPf/u/8AAAAAHgD3/7b/AAAAACUA9/+8/wAAAADq//f/p/8AAAAA4//3/6H/AAAAANv/9/+m/wAAAAAeAPP/yf8AAAAA4//z/7T/AAAAAAAAhf9i//sBBAAfAKr/PAD8CgEA3/+r/z0A8Pr6ABAAff8z//sBBADr/4H/NP/7AQQAAgCh/0v/+wEEAA4Alv8r//oBBADy/5n/LP/6AQQAIgDF/xkA6QYFANf/zP8gAOT++QAyAPP/OQAAAAAAyv/y/ykAAAAAAAAAmf+N//IAAAD//5D/Jf/6AQQAHACn/67/9Qz9AOT/qP+u//MB/wD//47/Of/6AQQAMgDx/0UAAAAAAMr/8P81AAAAAAAAAIz/XgAQ/vwAAgB8/3gADv/wAA0AZ/+KABn89AAVAEv/kgAs+fsAHAAw/5wARPsEAB4AFv+rAET7BAAqAPf/KwAAAAAAMgD3/yYAAAAAADkA9/8sAAAAAADR//b/HAAAAAAAyv/2/xYAAAAAAML/9v8bAAAAAAABAJb/Qf/7AQQAAQCa/zv/+wEEADsAhP8q//oBBABCAJn/Kf/6AQQAOQCq/zP/+gEEAMH/kf8u//oBBAC9/6j/Lv/6AQQAzf+1/zf/+gEEAB4A8f/V/wAAAADj//H/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACADcADQA4ABAAt/8L/7j+RwACALYAAAAuAMj/SgD+CgEAyv/Q/1AAD/QBAAAAn//u/wEAAAAAAKb/NQABAAAAGwCT/1f/+wEFAOf/mf9Z//sBBQAAAKT/sf/0AAAAAgCm/zj/+wEFABMAbv9v/wACBQA1ADn/gf8AAgUA6v9y/3H/CgD+AMX/R/+P/woA/gArAK7/3f/3DPwA1P+0/9z/+AEBABAAe/8///sBBQDr/3//QP/7AQUAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAAIX/Yv/7AQUAHwCq/zwA/AoBAN//q/89APD6+gAQAHz/M//7AQUA6/+B/zT/+wEFAAIAof9L//sBBQAOAJX/K//7AQUA8v+Z/yz/+wEFACIAxf8ZAOkGBQDX/8z/IADk/vkAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAJn/jf/yAAAA//+P/yX/+wEFABwAp/+u//UM/ADk/6j/rv/zAf8A//+O/zn/+wEFADIA8f9FAAAAAADK//D/NQAAAAAAAACM/14AEf78AAIAff94AA4A7wANAGf/igAZ/PUAFgBM/5MAK/n7ABwAMP+cAET7BAAeABb/qwBE+wQAKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAQCW/0H/+wEFAAEAmv87//sBBQA7AIP/Kv/7AQUAQgCY/yj/+wEFADkAqv8z//sBBQDA/5L/L//7AQUAvf+o/y7/+wEFAM7/tv83//sBBQAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALf/DP+4/kcAAgC2AAAALgDI/0oA/goBAMr/0P9QAA/0AQAAAJ//7v8BAAAAAACm/zUAAQAAABsAk/9X//sBBQDo/5n/Wf/7AQUAAACk/7H/9AAAAAIAp/84//sBBQASAG7/b/8AAgUANQA5/4D/AAIFAOr/c/9x/wkB/gDF/0b/j/8JAf4AKwCu/93/9wz8ANX/tP/c//gBAQAQAHv/P//7AQUA6/9//0D/+wEFABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACF/2L/+wEFAB8Aqv88APwKAQDf/6z/PQDw+/oAEAB8/zP/+wEFAOv/gf80//sBBQACAKH/S//7AQUADgCV/yv/+wEFAPL/mf8s//sBBQAiAMX/GQDpBgUA1//M/yAA5P75ADIA8/85AAAAAADK//L/KQAAAAAAAACZ/43/8gAAAP//j/8l//sBBQAcAKf/rv/1DPwA5P+o/67/8wH/AP//jv85//sBBQAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAjP9eABH++wACAH3/eAAOAO8ADQBo/4oAGfz1ABYATf+TACv5+wAcADH/nABD+wQAHgAX/6sAQ/sEACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAEAlv9B//sBBQABAJr/Ov/7AQUAOwCD/yn/+wEFAEIAmP8o//sBBQA5AKn/M//7AQUAwP+S/y//+wEFAL3/qf8u//sBBQDO/7b/OP/7AQUAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAC3/w3/uP5HAAIAtgAAAC4AyP9KAP4KAQDK/9D/UAAP9AEAAACf/+7/AQAAAAAApv81AAIAAAAbAJP/V//7AQUA6P+Z/1n/+wEFAAAApP+x//QAAAACAKf/N//7AQUAEgBu/2//AAIFADUAOf+A/wACBQDq/3P/cf8JAf8AxP9G/47/CQH/ACsArv/d//cL/ADU/7T/3P/4AAEAEAB7/z//+wEFAOv/f/9A//sBBQAWAPf/u/8AAAAAHgD3/7b/AAAAACUA9/+8/wAAAADq//f/p/8AAAAA4//3/6H/AAAAANv/9/+m/wAAAAAeAPP/yf8AAAAA4//z/7T/AAAAAAAAhf9i//sBBQAfAKr/PAD8CQEA3/+s/z0A8Pv6ABAAfP8z//sBBQDr/4H/NP/7AQUAAgCh/0v/+wEFAA4Alf8r//sBBQDy/5n/LP/7AQUAIgDG/xkA6QYFANf/zP8gAOT++QAyAPP/OQAAAAAAyv/y/ykAAAAAAAAAmf+N//IAAAD//4//Jf/7AQUAHACn/67/9Qz9AOT/qP+u//MA/wD//47/Of/7AQUAMgDx/0UAAAAAAMr/8P81AAAAAAAAAIz/XgAS/vsAAgB+/3gADgDuAA4Aaf+KABn99QAWAE7/lAAr+voAHAAy/5wAQ/sEAB4AGP+rAEP7BAAqAPf/KwAAAAAAMgD3/yYAAAAAADkA9/8sAAAAAADR//b/HAAAAAAAyv/2/xYAAAAAAML/9v8bAAAAAAABAJf/Qf/7AQUAAQCa/zr/+wEFADsAg/8p//sBBQBCAJj/KP/7AQUAOQCp/zP/+wEFAMD/kv8v//sBBQC9/6n/Lv/7AQUAzv+2/zj/+wEFAB4A8f/V/wAAAADj//H/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACADcADQA4ABAAt/8N/7j+RwACALUAAAAuAMj/SgD+CgEAy//Q/1AAD/QBAAAAn//u/wEAAAAAAKb/NQACAAAAGwCT/1f/+wEFAOj/mf9Z//sBBQAAAKT/sf/0AAAAAgCn/zf/+wEFABIAbv9v/wECBAA2ADr/gf8BAgQA6v9z/3H/CAH/AMT/R/+O/wgB/wAsAK7/3P/3DfsA1P+0/9z/+AEBABAAe/8///sBBQDr/3//QP/7AQUAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAAIX/Yv/7AQUAHwCq/zwA/AkBAN//rP89APD7+gAQAHz/M//7AQUA6/+B/zT/+wEFAAIAof9L//sBBQAOAJX/K//7AQUA8v+Z/yz/+wEFACIAxv8ZAOkGBQDX/8z/IADk//kAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAJn/jf/yAAAA//+P/yX/+wEFABwAp/+u//UN/ADk/6j/rv/zAP8A//+O/zn/+wEFADIA8f9FAAAAAADK//D/NQAAAAAAAACM/14AE/77AAIAfv95AA4A7gAOAGr/iwAZ/fUAFwBO/5QAK/r6AB0AMv+dAEL7BAAfABj/qgBC+wQAKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAQCX/0H/+wEFAAEAmv86//sBBQA7AIP/Kf/7AQUAQgCX/yj/+wEFADkAqf8z//sBBQDA/5P/L//7AQUAvf+p/y7/+wEFAM7/tv84//sBBQAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALf/Df+4/kcAAgC1AAAALgDI/0oA/goBAMv/0P9QAA/0AQAAAJ//7v8BAAAAAACm/zUAAgAAABsAk/9X//sBBQDo/5n/Wf/7AQUAAACk/7H/9AAAAAIAp/83//sBBQASAG7/b/8CAgMAOAA8/4L/AgIDAOr/c/9x/wgBAADD/0f/jv8IAQAALACu/93/9wz8ANT/tP/c//gBAQAQAHv/Pv/7AQUA6/9//0D/+wEFABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACF/2L/+wEFAB8Aqv88APwJAQDf/6z/PQDw+/oAEAB8/zP/+wEFAOv/gf80//sBBQACAKH/S//7AQUADgCV/yv/+wEFAPL/mf8s//sBBQAiAMb/GQDpBgUA1//M/yAA5P75ADIA8/85AAAAAADK//L/KQAAAAAAAACZ/43/8gAAAP//j/8l//sBBQAcAKf/rv/1DfwA5P+o/67/8wH/AP//jv85//sBBQAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAjP9eABP++wACAH//eQAOAO4ADgBq/4sAGf31ABcAT/+UACv6+gAdADL/nQBC+wQAHwAY/6oAQvsEACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAEAlv9B//sBBQABAJr/Ov/7AQUAOwCD/yn/+wEFAEIAl/8o//sBBQA5AKn/M//7AQUAwP+T/y//+wEFAL3/qf8u//sBBQDO/7b/OP/7AQUAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAC3/w3/uP5IAAIAtgAAAC4AyP9JAP4GAQDL/9D/UAAP9AEAAACf/+7/AQAAAAAApv81AAIAAAAbAJP/V//7AQUA6P+Z/1n/+wEFAAAApP+x//QAAAACAKf/N//7AQUAEgBu/2//AwEBADkAPf+D/wMBAQDq/3P/cf8IAQAAw/9I/47/CAEAACwArv/d//cN/ADV/7T/3P/4AgEAEAB7/z//+wEFAOv/f/9A//sBBQAWAPf/u/8AAAAAHgD3/7b/AAAAACUA9/+8/wAAAADq//f/p/8AAAAA4//3/6H/AAAAANv/9/+m/wAAAAAeAPP/yf8AAAAA4//z/7T/AAAAAAAAhf9i//sBBQAgAKr/OwD9BQEA3/+s/z0A8Pv6ABAAfP8z//sBBQDr/4H/NP/7AQUAAgCh/0v/+wEFAA4Alf8r//sBBQDy/5n/LP/7AQUAJgDE/xgA6QIDANf/zP8gAOT++QAyAPP/OQAAAAAAyv/y/ykAAAAAAAAAmf+N//IAAAD//4//Jf/7AQUAHACn/67/9Q38AOT/qP+u//MB/wD//47/Of/7AQUAMgDx/0UAAAAAAMr/8P81AAAAAAAAAIz/XgAS/vsAAgB+/3kADgDuAA4Aaf+LABn99QAXAE7/lAAr+voAHQAy/50AQvsEAB8AGP+rAEL7BAAqAPf/KwAAAAAAMgD3/yYAAAAAADkA9/8sAAAAAADR//b/HAAAAAAAyv/2/xYAAAAAAML/9v8bAAAAAAABAJf/Qf/7AQUAAQCa/zr/+wEFADsAg/8p//sBBQBCAJf/KP/7AQUAOQCp/zP/+wEFAMD/k/8v//sBBQC9/6n/Lv/7AQUAzv+2/zj/+wEFAB4A8f/V/wAAAADj//H/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACADcADQA4ABAAt/8N/7j+RwACALYAAAAuAMj/SgD+CgEAyv/Q/1AAD/MCAAAAn//u/wEAAAAAAKb/NQACAAAAGwCT/1f/+wEFAOj/mf9Z//sBBQAAAKT/sf/0AAAAAgCn/zf/+wEFABMAbv9v/wMBAQA6AD7/hP8DAQEA6v9z/3H/CAEAAMP/SP+O/wgBAAArAK7/3f/3DPwA1f+0/9z/+AIBABAAe/8///sBBQDr/3//QP/7AQUAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAAIX/Yv/7AQUAHwCq/zwA/AoBAN//rP89APD6+gAQAHz/M//7AQUA6/+B/zT/+wEFAAIAof9L//sBBQAOAJX/K//7AQUA8v+Z/yz/+wEFACEAxf8ZAOkHBQDX/8z/IADk/fgAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAJn/jf/yAAAA//+P/yX/+wEFABwAp/+u//UM/QDk/6j/rv/zAv8A//+O/zn/+wEFADIA8f9FAAAAAADK//D/NQAAAAAAAACM/14AEv77AAIAfv94AA4A7wAOAGn/igAZ/fUAFgBO/5MAK/r7ABwAMv+cAEP7BAAeABj/qwBD+wQAKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAQCX/0H/+wEFAAEAmv86//sBBQA7AIP/Kf/7AQUAQgCY/yj/+wEFADkAqf8z//sBBQDA/5L/L//7AQUAvf+p/y7/+wEFAM7/tv84//sBBQAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALf/DP+4/kcAAgC3AAAALgDI/0oA/goBAMr/0P9QAA/0AQAAAJ//7v8BAAAAAACm/zUAAgAAABsAk/9X//sBBADn/5n/Wf/7AQQAAACk/7H/9AAAAAIAp/84//sBBAATAG7/b/8CAQIAOQA9/4P/AgECAOv/cv9x/wkB/wDE/0f/j/8JAf8AKwCu/93/9wz8ANX/tP/c//gCAQAQAHv/P//7AQQA6/9//0D/+wEEABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACF/2L/+wEEAB8Aqv88APwJAQDf/6z/PQDw+/oAEAB9/zP/+wEEAOv/gf80//sBBAACAKH/TP/7AQQADgCW/yv/+wEEAPL/mf8s//sBBAAiAMb/GQDpBgUA1//M/yAA5P75ADIA8/85AAAAAADK//L/KQAAAAAAAACZ/43/8gAAAP//kP8l//sBBAAcAKf/rv/1DP0A5P+o/67/8wL/AP//jv85//sBBAAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAjP9eABH+/AACAH3/eAAOAO8ADQBo/4oAGfz1ABYATf+TACz5+wAcADH/nABE+wQAHgAX/6wARPsEACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAEAl/9B//sBBAABAJr/Ov/7AQQAOwCE/yr/+wEEAEIAmf8p//sBBAA5AKr/M//7AQQAwf+R/y7/+wEEAL3/qP8u//sBBADN/7X/N//7AQQAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAC3/wz/uP5HAAIAtwAAAC4AyP9KAP4KAQDK/9D/UAAP9AEAAACf/+7/AQAAAAAApv81AAIAAAAbAJP/WP/6AQQA5/+Y/1n/+gEEAAAApP+x//QAAAACAKf/OP/6AQQAEwBu/2//AQEDADcAPP+C/wEBAwDr/3L/cP8LAP4Axf9H/5D/CwD+ACsArv/d//cM/ADV/7T/3P/4AgEAEQB7/z//+gEEAOv/f/9A//oBBAAWAPf/u/8AAAAAHgD3/7b/AAAAACUA9/+8/wAAAADq//f/p/8AAAAA4//3/6H/AAAAANv/9/+m/wAAAAAeAPP/yf8AAAAA4//z/7T/AAAAAAAAhf9i//oBBAAfAKr/PAD8CQEA3/+s/z0A8Pv6ABAAff8z//oBBADr/4H/NP/6AQQAAgCh/0z/+gEEAA4Alv8r//oBBADy/5n/LP/6AQQAIgDG/xkA6QYFANf/zP8gAOT++QAyAPP/OQAAAAAAyv/y/ykAAAAAAAAAmf+N//IAAAD//5D/Jf/6AQQAHACn/67/9Qz9AOT/qP+u//MC/wD//47/Of/6AQQAMgDx/0UAAAAAAMr/8P81AAAAAAAAAIz/XgAQ/vwAAgB9/3gADv/wAA0AaP+KABn89AAVAEz/kwAs+fsAHAAx/5wARfsEAB4AF/+sAEX7BAAqAPf/KwAAAAAAMgD3/yYAAAAAADkA9/8sAAAAAADR//b/HAAAAAAAyv/2/xYAAAAAAML/9v8bAAAAAAABAJf/Qf/6AQQAAQCa/zr/+gEEADwAhf8q//oBBABCAJr/Kf/6AQQAOQCr/zT/+gEEAMH/kf8u//oBBAC9/6j/Lv/6AQQAzf+1/zf/+gEEAB4A8f/V/wAAAADj//H/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACADcADQA4ABAAt/8M/7j+RwACALcAAAAuAMj/SgD+CgEAyv/Q/1AAD/QBAAAAn//u/wEAAAAAAKb/NQACAAAAGwCT/1j/+gEEAOf/mP9Z//oBBAAAAKT/sf/0AAAAAgCn/zj/+gEEABMAbv9v/wEBBAA2ADv/gf8BAQQA6/9y/3D/DAD+AMb/R/+R/wwA/gArAK7/3f/3DPwA1f+0/9z/+AIAABEAe/8///oBBADr/3//QP/6AQQAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAAIX/Yv/6AQQAHwCq/zwA/AkBAN//rP89APD7+gAQAH3/M//6AQQA6/+B/zT/+gEEAAIAof9M//oBBAAOAJb/K//6AQQA8v+Z/yz/+gEEACIAxv8ZAOkGBQDX/8z/IADk/vkAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAJn/jf/yAAAA//+Q/yX/+gEEABwAp/+u//UM/QDk/6j/rv/zAv8A//+O/zn/+gEEADIA8f9FAAAAAADK//D/NQAAAAAAAACM/14AEP/8AAIAff94AA7/8AAMAGf/igAZ/PQAFQBM/5MALPn7ABsAMP+cAEX7BAAeABf/rABF+wQAKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAQCX/0H/+gEEAAEAmv86//oBBAA8AIX/Kv/6AQQAQgCa/yn/+gEEADkAq/80//oBBADB/5H/Lv/6AQQAvf+n/y7/+gEEAM3/tf83//oBBAAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALf/Av+4/kgAAgCuAAAALgDI/0oA/wcBAMz/0P9QAA/3AQAAAJz/7v8BAAAAAACk/zUAAgAAABsAnv9X//MBAwDn/6L/Wf/zAQMAAACm/7H/8QAAAAIAuv87/+4AAwATAHX/Z///AQMAOABC/3f//wEDAOv/eP9p/wv//QDG/0v/h/8L//0AKwCu/97/9wv8ANX/tP/d//kCAQARAIv/Ov/zAQMA7P+O/zv/8wEDABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACO/1//8wEDACAAp/87APsHAQDf/6n/PADw/fwAEQCP/y//8wEDAOz/kf8w//MBAwACAK3/Tf/uAAMADgCo/yv/9QEDAPL/qv8s//UBAwAlAMP/GgDqBAQA1f/J/x8A5v/7ADIA8/85AAAAAADK//L/KQAAAAAAAACc/4z/7AAAAP//ov8k//UBAwAcAKn/rv/zDP0A5P+q/67/8QL+AAAAnv83//UBAwAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAif9eAAz//gABAHj/dgAN//QACQBh/4gAF/32ABEARf+QACn6/AAWACj/mAA/+wMAGAAN/6MAP/sDACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAEAp/9A/+4AAwABAK3/Of/uAAMAPACY/yj/9QEDAEIArf8q//UBAwA4ALz/N//1AQMAwf+h/y3/9QEDALz/t/8v//UBAwDM/8P/O//1AQMAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAC3//b+uP5IAAIAnQAAAC0AyP9LAAECAQDP/9H/TwAQ/AAAAACY/+7/AAAAAAAAoP81AAIAAAAaAK//Wf/nAAIA5v+x/1r/5wACAAAAqP+x/+sAAAACANX/SP/YAAIAFACD/13//wECADoAUf9t//8BAgDr/4T/Xv8L/f0Axv9X/3r/C/39ACsArv/f//gL/ADU/7X/3v/6AgEAEgCk/zf/5wACAO3/pv84/+cAAgAWAPf/u/8AAAAAHgD3/7b/AAAAACUA9/+8/wAAAADq//f/p/8AAAAA4//3/6H/AAAAANv/9/+m/wAAAAAeAPP/yf8AAAAA4//z/7T/AAAAAAAAnP9b/+cAAgAgAKT/OgD7AgEA3/+m/zsA8QH/ABIAq/8u/+cAAgDt/63/L//nAAIAAQC//1P/2AACAA4Awv8w/+wAAgDy/8P/Mf/sAAIAKgDB/xoA7AABANL/xf8fAOkD/wAyAPP/OQAAAAAAyv/y/ykAAAAAAAAAoP+K/+MAAAAAAL7/KP/sAAIAHACt/6//8Qv+AOT/rf+v/+8B/gAAALX/Ov/sAAIAMgDx/0UAAAAAAMr/8P81AAAAAAAAAIf/XgAGAAAAAABy/3QACv/7AAMAWf+EABX++QAJADz/iwAj/f4ADAAe/44AM/wAAA4AAf+SADP8AAAqAPf/KwAAAAAAMgD3/yYAAAAAADkA9/8sAAAAAADR//b/HAAAAAAAyv/2/xYAAAAAAML/9v8bAAAAAAABAMD/Rf/YAAIAAQDM/z7/2AACAD0AtP8r/+wAAgBCAMn/Mv/sAAIANwDV/0H/7AACAMH/uf8v/+wAAgC8/87/Nv/sAAIAy//Y/0T/7AACAB4A8f/V/wAAAADj//H/wP8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAACADcADQA4ABAAtf/v/rj+SQACAJIAAAAsAMj/TAAC/gEA0f/Q/08AEAH+AAAAlP/u//8AAAAAAJ3/NAADAAAAGgC9/13/3AABAOb/vf9e/9wAAQAAAKr/sv/mAAAAAQDo/13/wwAAABQAkf9W//8AAAA8AGD/Z///AAAA7P+R/1b/C/v+AMX/ZP9x/wv7/gArAK7/4P/5CvwA1P+2/+D/+wEBABIAu/86/9wAAQDt/7v/Ov/cAAEAFgD3/7v/AAAAAB4A9/+2/wAAAAAlAPf/vP8AAAAA6v/3/6f/AAAAAOP/9/+h/wAAAADb//f/pv8AAAAAHgDz/8n/AAAAAOP/8/+0/wAAAAAAAKn/Wf/cAAEAIQCh/zoA+v0AAN//ov86APEGAQASAMT/Mv/cAAEA7f/F/zP/3AABAAAAzf9b/8MAAAAOANj/Ov/jAAEA8v/Y/zr/4wABAC8Avv8bAO78/wDP/8L/HwDsBwIAMgDz/zkAAAAAAMr/8v8pAAAAAAAAAKT/if/bAAAAAADV/zD/4wABABwAr/+w/+8L/gDk/7D/sP/uAf0AAADJ/0D/4wABADIA8f9FAAAAAADK//D/NQAAAAAAAACE/18AAAACAP7/bP9wAAkAAgD9/1P/gAAS//sAAAA1/4UAH///AAEAF/+FACj//wADAPr+gAAo//8AKgD3/ysAAAAAADIA9/8mAAAAAAA5APf/LAAAAAAA0f/2/xwAAAAAAMr/9v8WAAAAAADC//b/GwAAAAAAAADV/0//wwAAAAAA5/9P/8MAAAA9AM3/M//jAAEAQgDf/z7/4wABADcA5/9P/+MAAQDC/87/NP/jAAEAvP/h/0D/4wABAMv/6P9Q/+MAAQAeAPH/1f8AAAAA4//x/8D/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAgA3AA0AOAAQALP/7v64/ksAAgCPAAIALADJ/0wAAvsBANP/0f9OABAE/gAAAJP/7v//AAAAAACd/zQAAwAAABoAw/9g/9gAAADm/8P/YP/YAAAAAACr/7L/5AAAAAAA7f9n/7kAAAAVAJj/U/8AAAAAPABo/2b/AAAAAOz/mf9U/wv6/gDE/2v/bf8L+v4AKgCv/+H/+Qr8ANP/t//g//wBAgATAMX/Pf/YAAAA7f/F/z3/2AAAABYA9/+7/wAAAAAeAPf/tv8AAAAAJQD3/7z/AAAAAOr/9/+n/wAAAADj//f/of8AAAAA2//3/6b/AAAAAB4A8//J/wAAAADj//P/tP8AAAAAAACw/1r/2AAAACEAof85APr6AADe/6L/OQDyCAMAEwDQ/zb/2AAAAO3/0P82/9gAAAAAANP/X/+5AAAADgDi/z//4AAAAPL/4v8//+AAAAAxAL7/GwDv+v8Azf/B/x8A7QgEADIA8/85AAAAAADK//L/KQAAAAAAAACn/4j/2AAAAAAA3/81/+AAAAAcALH/sf/uC/4A5P+x/7H/7QH9AAAA0v9E/+AAAAAyAPH/RQAAAAAAyv/w/zUAAAAAAAAAhP9fAP3/BAD+/2v/bwAIAQUA+v9R/34AEQD8AP3/M/+CABwAAAD9/xX/gAAjAP4A/f/5/ngAIwD+ACoA9/8rAAAAAAAyAPf/JgAAAAAAOQD3/ywAAAAAANH/9v8cAAAAAADK//b/FgAAAAAAwv/2/xsAAAAAAAAA3v9W/7kAAAAAAPH/Wf+5AAAAPQDX/zj/4AAAAEIA6f9E/+AAAAA2AO//Vv/gAAAAwv/X/zj/4AAAALv/6f9F/+AAAADK/+//Vv/gAAAAHgDx/9X/AAAAAOP/8f/A/wAAAAAAAOz/zP4AAAAAAADe//n+AAAAAAIANwANADgAEAA=","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("QlkAAA8AUEZNX1tWNC4wMTVdIChjKSAxOTk5IFRoZSBMZWFybmluZyBDb21wYW55IFByb3BlcnRpZXMsIEluYy4gKEhpIE1vbSwgaW5kZWVkISkAtv/1/uv+SAABAJMABQAuAMf/SgAAAAAAz//J/0EAAAAAAAAAk/8AAAAAAAAAAI//QQAAAAAAGgBt/3L/AAAAAOb/bf9y/wAAAAAAAJz/wv8AAAAAAAB4/0//AAAAABQASf+T/wAAAAA8ABj/pf8AAAAA7P9J/5P/AAAAAMT/Gf+l/wAAAAAeALD/7P8AAAAA1P+5/+X/AAAAABMAT/9h/wAAAADt/0//Yf8AAAAAFgD2/7v/AAAAAB4A9v+1/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+g/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAAAAFz/g/8AAAAAIACS/0UAAAAAAN//kf9FAAAAAAATAE//Vf8AAAAA7f9P/1X/AAAAAAAAdP9p/wAAAAAOAGf/Sv8AAAAA8v9n/0r/AAAAACsAqv8iAAAAAADU/6X/HwAAAAAAMQDy/zkAAAAAAMr/8v8pAAAAAAAAAH7/pf8AAAAAAABe/0X/AAAAABsAnv+9/wAAAADk/57/vf8AAAAAAABf/1j/AAAAADEA8P9EAAAAAADK/+//NAAAAAAAAABz/2kAAAAAAAAAW/97AAAAAAAAAD//hQAAAAAAAAAi/3wAAAAAAAAADP9oAAAAAAAAAAD/TQAAAAAAKQD2/ysAAAAAADEA9v8lAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8VAAAAAADC//X/GwAAAAAAAABt/2L/AAAAAAAAb/9Y/wAAAAA9AFr/TP8AAAAAQgBv/0n/AAAAADYAgf9R/wAAAADB/1v/TP8AAAAAu/9w/0n/AAAAAMr/gf9R/wAAAAAeAPD/1f8AAAAA4//w/7//AAAAAAAA7P///gAAAAAAAN7/LP8AAAAAAAC3//n+6/5KAAEAjgAAAC4AyP9JAP//AADQ/8n/QQAAAQAAAACX//z//wD/AAAAk/89AAAAAAAdAHj/a/////wA6f90/2r////8AAAAof++//4A/gADAIL/SP////wAGgBT/4v////8AEUAJv+e/////ADy/1D/iv////wAzv8b/5r////8ACAAsf/r//8CAADT/7n/4////wEAGQBb/1r////8APP/V/9Z/////AAWAPb/u/8AAAAAHgD2/7X/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6D/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAAQAZf97/////AAhAJX/QQD//wAA3/+V/0EA/wEAABkAW/9O/////AD0/1j/Tf////wAAgB+/2L////8ABMAcv9D/////AD2/3D/Qv////wALQCu/x8A/P8AANP/qf8bAPwBAQAxAPL/OQAAAAAAyv/y/ykAAAAAAAEAhP+f//4A/AAFAGn/Pf////wAGgCj/7v//AIAAOP/oP+7//7/AQAFAGn/Uf////wAMQDw/0QAAAAAAMr/7/80AAAAAAAAAHf/ZQAAAAMA/v9f/3cAAAADAPz/Qv+AAAH/AgD7/yX/eQAA/f4A/f8P/2UA/vv+AAEABP9JAP77/gApAPb/KwAAAAAAMQD2/yUAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xUAAAAAAML/9f8bAAAAAAADAHf/W/////wAAwB5/1H////8AEMAav9G/////ABFAID/Q/////wAOACQ/0z////8AMf/X/9D/////AC//3T/QP////wAzP+G/0n////8AB4A8P/V/wAAAADj//D/v/8AAAAAAADs///+AAAAAAAA3v8s/wAAAAAAALb//f7r/ksAAQCJAAAALQDI/0kA//4AAND/yf9BAAADAQD//5n/9//+AP4A//+U/zgAAAAAAB0Ag/9j//3++QDq/3v/Yf/9/vkA/v+j/7r/+gD8AAMAjf9A//3++QAcAF3/gf/9/vkASgAy/5P//f75APT/Vv9///3++QDU/x//jf/9/vkAIgCv/+f//QX/ANH/t//g//3+AQAbAGb/Uf/9/vkA9/9g/0///f75ABYA9v+7/wAAAAAeAPb/tf8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/oP8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAABgBt/3L//f75ACAAl/88APz+AADe/5b/PAD9AwEAHABn/0X//f75APf/Yf9D//3++QADAIf/Wf/9/vkAFAB+/zv//f75APj/ev85//3++QAtALL/HAD4/gAA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RgCe/zX/+/73ADcAq/8+//v+9wDN/2//Lf/7/vcAwv+E/yz/+/73AM3/lf82//v+9wAeAPD/1f8AAAAA4//w/7//AAAAAAAA7P///gAAAAAAAN7/LP8AAAAAAAC2/w//6/5LAAEAmgAAAC0AyP9JAP/+AADQ/8n/QgABAwEA//+Z//f//gD+AP//lP84AAAAAAAdAIP/Y//9/vkA6v97/2H//f75AP7/o/+6//oA/AADAI3/QP/9/vkAHABd/4H//f75AEoAMv+T//3++QD0/1b/f//9/vkA1P8f/43//f75ACAAr//n//0EAADP/7f/3//9/AEAGwBm/1H//f75APf/YP9P//3++QAWAPb/u/8AAAAAHgD2/7X/AAAAACUA9v+8/wAAAADq//b/p/8AAAAA4//2/6D/AAAAANv/9v+m/wAAAAAeAPL/yf8AAAAA4//y/7T/AAAAAAYAbf9y//3++QAgAJf/PAD8/gAA3v+W/zwA/QMBABwAZ/9F//3++QD3/2H/Q//9/vkAAwCH/1n//f75ABQAfv87//3++QD4/3r/Of/9/vkALQCz/xwA+P4AAND/rf8YAPgDAQAxAPL/OQAAAAAAyv/y/ykAAAAAAAEAiv+Y//oB+gAIAHT/NP/9/vkAGQCn/7b/9wQAAOH/of+2//v8AQAHAHT/SP/9/vkAMQDw/0QAAAAAAMr/7/80AAAAAAD//3j/YAALAggA/P9m/3cADwMEAPn/T/+KABAFAgD3/zH/jQAGFwwA5v8c/38A+yQeAM7/JP9vAPskHgApAPb/KwAAAAAAMQD2/yUAAAAAADkA9v8sAAAAAADR//X/HAAAAAAAyv/1/xUAAAAAAML/9f8bAAAAAAAEAIH/U//9/vkABACD/0j//f75AEUAef8///3++QBGAI//Pf/9/vkANwCe/0X//f75AMv/Zv84//3++QDB/3v/Nv/9/vkAzf+N/0D//f75AB4A8P/V/wAAAADj//D/v/8AAAAAAADs///+AAAAAAAA3v8s/wAAAAAAALf//v7r/koAAQCVAAAALgDH/0kA//8AAND/yf9BAAABAAAAAJb//P//AP8AAACS/z0AAAAAAB0Ad/9r/////ADp/3P/av////wAAACg/77//gD+AAMAgf9I/////AAaAFL/i/////wARQAl/57////8APL/T/+K/////ADO/xr/mv////wAIACw/+v//wIAANL/uP/j///+AQAZAFr/Wv////wA8/9W/1n////8ABYA9v+7/wAAAAAeAPb/tf8AAAAAJQD2/7z/AAAAAOr/9v+n/wAAAADj//b/oP8AAAAA2//2/6b/AAAAAB4A8v/J/wAAAADj//L/tP8AAAAABABk/3v////8ACEAlP9BAP//AADf/5T/QQD/AQAAGQBa/07////8APT/V/9N/////AACAH3/Yv////wAEwBx/0P////8APb/b/9C/////AAtAK3/HwD8/wAA0/+o/xsA/AEBADEA8v85AAAAAADK//L/KQAAAAAAAQCD/5///gD8AAUAaP89/////AAaAKP/uv/7AgAA4/+g/7r//f4BAAUAaP9R/////AAxAPD/RAAAAAAAyv/v/zQAAAAAAAAAdv9lAAQAAwD+/2D/eQAGAAEA/v9F/4cABwIAAP3/J/+DAAIJAwD3/xD/cQD8DwcA6/8J/1YA/A8HACkA9v8rAAAAAAAxAPb/JQAAAAAAOQD2/ywAAAAAANH/9f8cAAAAAADK//X/FQAAAAAAwv/1/xsAAAAAAAMAdv9b/////AADAHj/Uf////wAQwBp/0b////8AEUAf/9D/////AA4AI//TP////wAx/9e/0P////8AL//c/9A/////ADM/4X/Sf////wAHgDw/9X/AAAAAOP/8P+//wAAAAAAAOz///4AAAAAAADe/yz/AAAAAAAAtv/1/uv+SAABAJMABgAuAMf/SgAAAAAAz//J/0EAAAAAAAAAk/8AAAAAAAAAAI//QQAAAAAAGgBt/3L/AAAAAOb/bf9y/wAAAAAAAJz/wv8AAAAAAAB4/0//AAAAABQASf+T/wAAAAA8ABj/pf8AAAAA7P9J/5P/AAAAAMT/Gf+l/wAAAAAeALD/7P8AAAAA1P+5/+X/AAAAABMAT/9h/wAAAADt/0//Yf8AAAAAFgD2/7v/AAAAAB4A9v+1/wAAAAAlAPb/vP8AAAAA6v/2/6f/AAAAAOP/9v+g/wAAAADb//b/pv8AAAAAHgDy/8n/AAAAAOP/8v+0/wAAAAAAAFz/g/8AAAAAIACS/0UAAAAAAN//kf9FAAAAAAATAE//Vf8AAAAA7f9P/1X/AAAAAAAAdP9p/wAAAAAOAGf/Sv8AAAAA8v9n/0r/AAAAACsAqv8iAAAAAADU/6X/HwAAAAAAMQDy/zkAAAAAAMr/8v8pAAAAAAAAAH7/pf8AAAAAAABe/0X/AAAAABsAnv+9/wAAAADk/57/vf8AAAAAAABf/1j/AAAAADEA8P9EAAAAAADK/+//NAAAAAAAAABz/2kAAAAAAAAAW/97AAAAAAAAAD//hQAAAAAAAAAi/3wAAAAAAAAADP9oAAAAAAAAAAD/TQAAAAAAKQD2/ysAAAAAADEA9v8lAAAAAAA5APb/LAAAAAAA0f/1/xwAAAAAAMr/9f8VAAAAAADC//X/GwAAAAAAAABt/2L/AAAAAAAAb/9Y/wAAAAA9AFr/TP8AAAAAQgBv/0n/AAAAADYAgf9R/wAAAADB/1v/TP8AAAAAu/9w/0n/AAAAAMr/gf9R/wAAAAAeAPD/1f8AAAAA4//w/7//AAAAAAAA7P///gAAAAAAAN7/LP8AAAAAAAA=","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
	],

	decoder = new AnimationDecoder(bunnyBHD);

for (let i = 0; i < BHTs.length; i++) {
	decoder.addAnimation(i, BHTs[i]);
}

let
	CAMERA_DISTANCE = 750,

	camera, scene, renderer, petGroup,
	mouseX = 0, mouseY = 0,
	displayHalfX = window.innerWidth / 2,
	displayHalfY = window.innerHeight / 2,

	ballMeshes = [],

	animationStart = Date.now(),

	animationIndex = 0,
	animationFrameIndex = 0;

function initScene() {
	camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
	camera.position.z = CAMERA_DISTANCE;
	scene = new THREE.Scene();
	scene.background = new THREE.Color(0xffffff);
	scene.fog = new THREE.Fog(0xffffff, 1, 100000);

	let
		material = new THREE.MeshNormalMaterial();

	petGroup = new THREE.Group();

	animationFrameIndex = 0;

	for (let i = 0; i < decoder.numBalls; i++) {
		let
			geometry = new THREE.SphereBufferGeometry(decoder.ballSizes[i] / 2, 16, 16),
			ball = new THREE.Mesh(geometry, material);

		ball.position.x = decoder.animations[animationIndex].frames[animationFrameIndex].balls[i].x;
		ball.position.y = -decoder.animations[animationIndex].frames[animationFrameIndex].balls[i].y;
		ball.position.z = decoder.animations[animationIndex].frames[animationFrameIndex].balls[i].z;
		ball.matrixAutoUpdate = false;
		ball.updateMatrix();

		ballMeshes.push(ball);

		petGroup.add(ball);
	}

	scene.add(petGroup);

	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.getElementById("container").appendChild(renderer.domElement);

	document.addEventListener('mousemove', onDocumentMouseMove, false);
	window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('click', e => {
		animationStart = Date.now();
		animationIndex = (animationIndex + 1) % decoder.animations.length;
		animationFrameIndex = -1;
	});
	window.addEventListener("wheel", e => {
		if (e.deltaY > 0) {
			CAMERA_DISTANCE *= 1.2;
		} else {
			CAMERA_DISTANCE /= 1.2;
		}
	});
}

function onWindowResize() {
	let
		displayWidth = renderer.domElement.clientWidth,
		displayHeight = renderer.domElement.clientHeight;

	displayHalfX = displayWidth / 2;
	displayHalfY = displayHeight / 2;
	camera.aspect = displayWidth / displayHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(displayWidth, displayHeight);
}

function onDocumentMouseMove(event) {
	mouseX = event.clientX - displayHalfX;
	mouseY = event.clientY - displayHalfY;
}

function animate() {
	requestAnimationFrame(animate);
	render();
}

function render() {
	let
		newFrameIndex = Math.round((Date.now() - animationStart) / 100) % decoder.animations[animationIndex].frames.length;

	if (newFrameIndex !== animationFrameIndex) {
		animationFrameIndex = newFrameIndex;

		for (let i = 0; i < decoder.numBalls; i++) {
			ballMeshes[i].position.x = decoder.animations[animationIndex].frames[newFrameIndex].balls[i].x;
			ballMeshes[i].position.y = -decoder.animations[animationIndex].frames[newFrameIndex].balls[i].y;
			ballMeshes[i].position.z = decoder.animations[animationIndex].frames[newFrameIndex].balls[i].z;

			ballMeshes[i].updateMatrix();
		}
	}

	petGroup.rotation.y = mouseX / displayHalfX * Math.PI * 2;

	camera.position.y = Math.sin(mouseY / displayHalfY * Math.PI / 2) * CAMERA_DISTANCE;
	camera.position.z = Math.cos(mouseY / displayHalfY * Math.PI / 2) * CAMERA_DISTANCE;

	camera.lookAt(scene.position);

	renderer.render(scene, camera);
}

initScene();
animate();

}).call(this,require("buffer").Buffer)
},{"./animation-decoder":1,"buffer":6,"three":8}],3:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],4:[function(require,module,exports){
//========================================================================================
// Globals
//========================================================================================

var Context = require("./context").Context;

var PRIMITIVE_TYPES = {
  UInt8: 1,
  UInt16LE: 2,
  UInt16BE: 2,
  UInt32LE: 4,
  UInt32BE: 4,
  Int8: 1,
  Int16LE: 2,
  Int16BE: 2,
  Int32LE: 4,
  Int32BE: 4,
  FloatLE: 4,
  FloatBE: 4,
  DoubleLE: 8,
  DoubleBE: 8
};

var SPECIAL_TYPES = {
  String: null,
  Buffer: null,
  Array: null,
  Skip: null,
  Choice: null,
  Nest: null,
  Bit: null
};

var aliasRegistry = {};
var FUNCTION_PREFIX = "___parser_";

var BIT_RANGE = [];
(function() {
  var i;
  for (i = 1; i <= 32; i++) {
    BIT_RANGE.push(i);
  }
})();

// Converts Parser's method names to internal type names
var NAME_MAP = {};
Object.keys(PRIMITIVE_TYPES)
  .concat(Object.keys(SPECIAL_TYPES))
  .forEach(function(type) {
    NAME_MAP[type.toLowerCase()] = type;
  });

//========================================================================================
// class Parser
//========================================================================================

//----------------------------------------------------------------------------------------
// constructor
//----------------------------------------------------------------------------------------

var Parser = function() {
  this.varName = "";
  this.type = "";
  this.options = {};
  this.next = null;
  this.head = null;
  this.compiled = null;
  this.endian = "be";
  this.constructorFn = null;
  this.alias = null;
};

//----------------------------------------------------------------------------------------
// public methods
//----------------------------------------------------------------------------------------

Parser.start = function() {
  return new Parser();
};

Object.keys(PRIMITIVE_TYPES).forEach(function(type) {
  Parser.prototype[type.toLowerCase()] = function(varName, options) {
    return this.setNextParser(type.toLowerCase(), varName, options);
  };

  var typeWithoutEndian = type.replace(/BE|LE/, "").toLowerCase();
  if (!(typeWithoutEndian in Parser.prototype)) {
    Parser.prototype[typeWithoutEndian] = function(varName, options) {
      return this[typeWithoutEndian + this.endian](varName, options);
    };
  }
});

BIT_RANGE.forEach(function(i) {
  Parser.prototype["bit" + i.toString()] = function(varName, options) {
    if (!options) {
      options = {};
    }
    options.length = i;
    return this.setNextParser("bit", varName, options);
  };
});

Parser.prototype.namely = function(alias) {
  aliasRegistry[alias] = this;
  this.alias = alias;
  return this;
};

Parser.prototype.skip = function(length, options) {
  if (options && options.assert) {
    throw new Error("assert option on skip is not allowed.");
  }

  return this.setNextParser("skip", "", { length: length });
};

Parser.prototype.string = function(varName, options) {
  if (!options.zeroTerminated && !options.length && !options.greedy) {
    throw new Error(
      "Neither length, zeroTerminated, nor greedy is defined for string."
    );
  }
  if ((options.zeroTerminated || options.length) && options.greedy) {
    throw new Error(
      "greedy is mutually exclusive with length and zeroTerminated for string."
    );
  }
  if (options.stripNull && !(options.length || options.greedy)) {
    throw new Error(
      "Length or greedy must be defined if stripNull is defined."
    );
  }
  options.encoding = options.encoding || "utf8";

  return this.setNextParser("string", varName, options);
};

Parser.prototype.buffer = function(varName, options) {
  if (!options.length && !options.readUntil) {
    throw new Error("Length nor readUntil is defined in buffer parser");
  }

  return this.setNextParser("buffer", varName, options);
};

Parser.prototype.array = function(varName, options) {
  if (!options.readUntil && !options.length && !options.lengthInBytes) {
    throw new Error("Length option of array is not defined.");
  }
  if (!options.type) {
    throw new Error("Type option of array is not defined.");
  }
  if (
    typeof options.type === "string" &&
    !aliasRegistry[options.type] &&
    Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.type]) < 0
  ) {
    throw new Error(
      'Specified primitive type "' + options.type + '" is not supported.'
    );
  }

  return this.setNextParser("array", varName, options);
};

Parser.prototype.choice = function(varName, options) {
  if (!options.tag) {
    throw new Error("Tag option of array is not defined.");
  }
  if (!options.choices) {
    throw new Error("Choices option of array is not defined.");
  }
  Object.keys(options.choices).forEach(function(key) {
    if (isNaN(parseInt(key, 10))) {
      throw new Error("Key of choices must be a number.");
    }
    if (!options.choices[key]) {
      throw new Error(
        "Choice Case " + key + " of " + varName + " is not valid."
      );
    }

    if (
      typeof options.choices[key] === "string" &&
      !aliasRegistry[options.choices[key]] &&
      Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.choices[key]]) < 0
    ) {
      throw new Error(
        'Specified primitive type "' +
          options.choices[key] +
          '" is not supported.'
      );
    }
  }, this);

  return this.setNextParser("choice", varName, options);
};

Parser.prototype.nest = function(varName, options) {
  if (!options.type) {
    throw new Error("Type option of nest is not defined.");
  }

  if (!(options.type instanceof Parser) && !aliasRegistry[options.type]) {
    throw new Error("Type option of nest must be a Parser object.");
  }

  return this.setNextParser("nest", varName, options);
};

Parser.prototype.endianess = function(endianess) {
  switch (endianess.toLowerCase()) {
    case "little":
      this.endian = "le";
      break;
    case "big":
      this.endian = "be";
      break;
    default:
      throw new Error("Invalid endianess: " + endianess);
  }

  return this;
};

Parser.prototype.create = function(constructorFn) {
  if (!(constructorFn instanceof Function)) {
    throw new Error("Constructor must be a Function object.");
  }

  this.constructorFn = constructorFn;

  return this;
};

Parser.prototype.getCode = function() {
  var ctx = new Context();

  if (!this.alias) {
    this.addRawCode(ctx);
  } else {
    this.addAliasedCode(ctx);
  }

  if (this.alias) {
    ctx.pushCode("return {0}(0).result;", FUNCTION_PREFIX + this.alias);
  } else {
    ctx.pushCode("return vars;");
  }

  return ctx.code;
};

Parser.prototype.addRawCode = function(ctx) {
  ctx.pushCode("var offset = 0;");

  if (this.constructorFn) {
    ctx.pushCode("var vars = new constructorFn();");
  } else {
    ctx.pushCode("var vars = {};");
  }

  this.generate(ctx);

  this.resolveReferences(ctx);

  ctx.pushCode("return vars;");
};

Parser.prototype.addAliasedCode = function(ctx) {
  ctx.pushCode("function {0}(offset) {", FUNCTION_PREFIX + this.alias);

  if (this.constructorFn) {
    ctx.pushCode("var vars = new constructorFn();");
  } else {
    ctx.pushCode("var vars = {};");
  }

  this.generate(ctx);

  ctx.markResolved(this.alias);
  this.resolveReferences(ctx);

  ctx.pushCode("return { offset: offset, result: vars };");
  ctx.pushCode("}");

  return ctx;
};

Parser.prototype.resolveReferences = function(ctx) {
  var references = ctx.getUnresolvedReferences();
  ctx.markRequested(references);
  references.forEach(function(alias) {
    var parser = aliasRegistry[alias];
    parser.addAliasedCode(ctx);
  });
};

Parser.prototype.compile = function() {
  this.compiled = new Function(
    "buffer",
    "callback",
    "constructorFn",
    this.getCode()
  );
};

Parser.prototype.sizeOf = function() {
  var size = NaN;

  if (Object.keys(PRIMITIVE_TYPES).indexOf(this.type) >= 0) {
    size = PRIMITIVE_TYPES[this.type];

    // if this is a fixed length string
  } else if (
    this.type === "String" &&
    typeof this.options.length === "number"
  ) {
    size = this.options.length;

    // if this is a fixed length buffer
  } else if (
    this.type === "Buffer" &&
    typeof this.options.length === "number"
  ) {
    size = this.options.length;

    // if this is a fixed length array
  } else if (this.type === "Array" && typeof this.options.length === "number") {
    var elementSize = NaN;
    if (typeof this.options.type === "string") {
      elementSize = PRIMITIVE_TYPES[NAME_MAP[this.options.type]];
    } else if (this.options.type instanceof Parser) {
      elementSize = this.options.type.sizeOf();
    }
    size = this.options.length * elementSize;

    // if this a skip
  } else if (this.type === "Skip") {
    size = this.options.length;

    // if this is a nested parser
  } else if (this.type === "Nest") {
    size = this.options.type.sizeOf();
  } else if (!this.type) {
    size = 0;
  }

  if (this.next) {
    size += this.next.sizeOf();
  }

  return size;
};

// Follow the parser chain till the root and start parsing from there
Parser.prototype.parse = function(buffer, callback) {
  if (!this.compiled) {
    this.compile();
  }

  return this.compiled(buffer, callback, this.constructorFn);
};

//----------------------------------------------------------------------------------------
// private methods
//----------------------------------------------------------------------------------------

Parser.prototype.setNextParser = function(type, varName, options) {
  var parser = new Parser();

  parser.type = NAME_MAP[type];
  parser.varName = varName;
  parser.options = options || parser.options;
  parser.endian = this.endian;

  if (this.head) {
    this.head.next = parser;
  } else {
    this.next = parser;
  }
  this.head = parser;

  return this;
};

// Call code generator for this parser
Parser.prototype.generate = function(ctx) {
  if (this.type) {
    this["generate" + this.type](ctx);
    this.generateAssert(ctx);
  }

  var varName = ctx.generateVariable(this.varName);
  if (this.options.formatter) {
    this.generateFormatter(ctx, varName, this.options.formatter);
  }

  return this.generateNext(ctx);
};

Parser.prototype.generateAssert = function(ctx) {
  if (!this.options.assert) {
    return;
  }

  var varName = ctx.generateVariable(this.varName);

  switch (typeof this.options.assert) {
    case "function":
      ctx.pushCode(
        "if (!({0}).call(vars, {1})) {",
        this.options.assert,
        varName
      );
      break;
    case "number":
      ctx.pushCode("if ({0} !== {1}) {", this.options.assert, varName);
      break;
    case "string":
      ctx.pushCode('if ("{0}" !== {1}) {', this.options.assert, varName);
      break;
    default:
      throw new Error(
        "Assert option supports only strings, numbers and assert functions."
      );
  }
  ctx.generateError('"Assert error: {0} is " + {0}', varName);
  ctx.pushCode("}");
};

// Recursively call code generators and append results
Parser.prototype.generateNext = function(ctx) {
  if (this.next) {
    ctx = this.next.generate(ctx);
  }

  return ctx;
};

Object.keys(PRIMITIVE_TYPES).forEach(function(type) {
  Parser.prototype["generate" + type] = function(ctx) {
    ctx.pushCode(
      "{0} = buffer.read{1}(offset);",
      ctx.generateVariable(this.varName),
      type
    );
    ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[type]);
  };
});

Parser.prototype.generateBit = function(ctx) {
  // TODO find better method to handle nested bit fields
  var parser = JSON.parse(JSON.stringify(this));
  parser.varName = ctx.generateVariable(parser.varName);
  ctx.bitFields.push(parser);

  if (
    !this.next ||
    (this.next && ["Bit", "Nest"].indexOf(this.next.type) < 0)
  ) {
    var sum = 0;
    ctx.bitFields.forEach(function(parser) {
      sum += parser.options.length;
    });

    var val = ctx.generateTmpVariable();

    if (sum <= 8) {
      ctx.pushCode("var {0} = buffer.readUInt8(offset);", val);
      sum = 8;
    } else if (sum <= 16) {
      ctx.pushCode("var {0} = buffer.readUInt16BE(offset);", val);
      sum = 16;
    } else if (sum <= 24) {
      var val1 = ctx.generateTmpVariable();
      var val2 = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = buffer.readUInt16BE(offset);", val1);
      ctx.pushCode("var {0} = buffer.readUInt8(offset + 2);", val2);
      ctx.pushCode("var {2} = ({0} << 8) | {1};", val1, val2, val);
      sum = 24;
    } else if (sum <= 32) {
      ctx.pushCode("var {0} = buffer.readUInt32BE(offset);", val);
      sum = 32;
    } else {
      throw new Error(
        "Currently, bit field sequence longer than 4-bytes is not supported."
      );
    }
    ctx.pushCode("offset += {0};", sum / 8);

    var bitOffset = 0;
    var isBigEndian = this.endian === "be";
    ctx.bitFields.forEach(function(parser) {
      ctx.pushCode(
        "{0} = {1} >> {2} & {3};",
        parser.varName,
        val,
        isBigEndian ? sum - bitOffset - parser.options.length : bitOffset,
        (1 << parser.options.length) - 1
      );
      bitOffset += parser.options.length;
    });

    ctx.bitFields = [];
  }
};

Parser.prototype.generateSkip = function(ctx) {
  var length = ctx.generateOption(this.options.length);
  ctx.pushCode("offset += {0};", length);
};

Parser.prototype.generateString = function(ctx) {
  var name = ctx.generateVariable(this.varName);
  var start = ctx.generateTmpVariable();

  if (this.options.length && this.options.zeroTerminated) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode(
      "while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});",
      start,
      this.options.length
    );
    ctx.pushCode(
      "{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);",
      name,
      this.options.encoding,
      start,
      this.options.length
    );
  } else if (this.options.length) {
    ctx.pushCode(
      "{0} = buffer.toString('{1}', offset, offset + {2});",
      name,
      this.options.encoding,
      ctx.generateOption(this.options.length)
    );
    ctx.pushCode("offset += {0};", ctx.generateOption(this.options.length));
  } else if (this.options.zeroTerminated) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.readUInt8(offset++) !== 0);");
    ctx.pushCode(
      "{0} = buffer.toString('{1}', {2}, offset - 1);",
      name,
      this.options.encoding,
      start
    );
  } else if (this.options.greedy) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.length > offset++);");
    ctx.pushCode(
      "{0} = buffer.toString('{1}', {2}, offset);",
      name,
      this.options.encoding,
      start
    );
  }
  if (this.options.stripNull) {
    ctx.pushCode("{0} = {0}.replace(/\\x00+$/g, '')", name);
  }
};

Parser.prototype.generateBuffer = function(ctx) {
  if (this.options.readUntil === "eof") {
    ctx.pushCode(
      "{0} = buffer.slice(offset);",
      ctx.generateVariable(this.varName)
    );
  } else {
    ctx.pushCode(
      "{0} = buffer.slice(offset, offset + {1});",
      ctx.generateVariable(this.varName),
      ctx.generateOption(this.options.length)
    );
    ctx.pushCode("offset += {0};", ctx.generateOption(this.options.length));
  }

  if (this.options.clone) {
    var buf = ctx.generateTmpVariable();

    ctx.pushCode(
      "var {0} = new Buffer({1}.length);",
      buf,
      ctx.generateVariable(this.varName)
    );
    ctx.pushCode("{0}.copy({1});", ctx.generateVariable(this.varName), buf);
    ctx.pushCode("{0} = {1}", ctx.generateVariable(this.varName), buf);
  }
};

Parser.prototype.generateArray = function(ctx) {
  var length = ctx.generateOption(this.options.length);
  var lengthInBytes = ctx.generateOption(this.options.lengthInBytes);
  var type = this.options.type;
  var counter = ctx.generateTmpVariable();
  var lhs = ctx.generateVariable(this.varName);
  var item = ctx.generateTmpVariable();
  var key = this.options.key;
  var isHash = typeof key === "string";

  if (isHash) {
    ctx.pushCode("{0} = {};", lhs);
  } else {
    ctx.pushCode("{0} = [];", lhs);
  }
  if (typeof this.options.readUntil === "function") {
    ctx.pushCode("do {");
  } else if (this.options.readUntil === "eof") {
    ctx.pushCode("for (var {0} = 0; offset < buffer.length; {0}++) {", counter);
  } else if (lengthInBytes !== undefined) {
    ctx.pushCode(
      "for (var {0} = offset; offset - {0} < {1}; ) {",
      counter,
      lengthInBytes
    );
  } else {
    ctx.pushCode("for (var {0} = 0; {0} < {1}; {0}++) {", counter, length);
  }

  if (typeof type === "string") {
    if (!aliasRegistry[type]) {
      ctx.pushCode("var {0} = buffer.read{1}(offset);", item, NAME_MAP[type]);
      ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[NAME_MAP[type]]);
    } else {
      var tempVar = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + type);
      ctx.pushCode("var {0} = {1}.result; offset = {1}.offset;", item, tempVar);
      if (type !== this.alias) ctx.addReference(type);
    }
  } else if (type instanceof Parser) {
    ctx.pushCode("var {0} = {};", item);

    ctx.pushScope(item);
    type.generate(ctx);
    ctx.popScope();
  }

  if (isHash) {
    ctx.pushCode("{0}[{2}.{1}] = {2};", lhs, key, item);
  } else {
    ctx.pushCode("{0}.push({1});", lhs, item);
  }

  ctx.pushCode("}");

  if (typeof this.options.readUntil === "function") {
    ctx.pushCode(
      " while (!({0}).call(this, {1}, buffer.slice(offset)));",
      this.options.readUntil,
      item
    );
  }
};

Parser.prototype.generateChoiceCase = function(ctx, varName, type) {
  if (typeof type === "string") {
    if (!aliasRegistry[type]) {
      ctx.pushCode(
        "{0} = buffer.read{1}(offset);",
        ctx.generateVariable(this.varName),
        NAME_MAP[type]
      );
      ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[NAME_MAP[type]]);
    } else {
      var tempVar = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + type);
      ctx.pushCode(
        "{0} = {1}.result; offset = {1}.offset;",
        ctx.generateVariable(this.varName),
        tempVar
      );
      if (type !== this.alias) ctx.addReference(type);
    }
  } else if (type instanceof Parser) {
    ctx.pushPath(varName);
    type.generate(ctx);
    ctx.popPath(varName);
  }
};

Parser.prototype.generateChoice = function(ctx) {
  var tag = ctx.generateOption(this.options.tag);
  if (this.varName) {
    ctx.pushCode("{0} = {};", ctx.generateVariable(this.varName));
  }
  ctx.pushCode("switch({0}) {", tag);
  Object.keys(this.options.choices).forEach(function(tag) {
    var type = this.options.choices[tag];

    ctx.pushCode("case {0}:", tag);
    this.generateChoiceCase(ctx, this.varName, type);
    ctx.pushCode("break;");
  }, this);
  ctx.pushCode("default:");
  if (this.options.defaultChoice) {
    this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);
  } else {
    ctx.generateError('"Met undefined tag value " + {0} + " at choice"', tag);
  }
  ctx.pushCode("}");
};

Parser.prototype.generateNest = function(ctx) {
  var nestVar = ctx.generateVariable(this.varName);
  if (this.options.type instanceof Parser) {
    ctx.pushCode("{0} = {};", nestVar);
    ctx.pushPath(this.varName);
    this.options.type.generate(ctx);
    ctx.popPath(this.varName);
  } else if (aliasRegistry[this.options.type]) {
    var tempVar = ctx.generateTmpVariable();
    ctx.pushCode(
      "var {0} = {1}(offset);",
      tempVar,
      FUNCTION_PREFIX + this.options.type
    );
    ctx.pushCode("{0} = {1}.result; offset = {1}.offset;", nestVar, tempVar);
    if (this.options.type !== this.alias) ctx.addReference(this.options.type);
  }
};

Parser.prototype.generateFormatter = function(ctx, varName, formatter) {
  if (typeof formatter === "function") {
    ctx.pushCode("{0} = ({1}).call(this, {0});", varName, formatter);
  }
};

Parser.prototype.isInteger = function() {
  return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\d+/);
};

//========================================================================================
// Exports
//========================================================================================

exports.Parser = Parser;

},{"./context":5}],5:[function(require,module,exports){
//========================================================================================
// class Context
//========================================================================================

//----------------------------------------------------------------------------------------
// constructor
//----------------------------------------------------------------------------------------

var Context = function() {
  this.code = "";
  this.scopes = [["vars"]];
  this.isAsync = false;
  this.bitFields = [];
  this.tmpVariableCount = 0;
  this.references = {};
};

//----------------------------------------------------------------------------------------
// public methods
//----------------------------------------------------------------------------------------

Context.prototype.generateVariable = function(name) {
  var arr = [];

  Array.prototype.push.apply(arr, this.scopes[this.scopes.length - 1]);
  if (name) {
    arr.push(name);
  }

  return arr.join(".");
};

Context.prototype.generateOption = function(val) {
  switch (typeof val) {
    case "number":
      return val.toString();
    case "string":
      return this.generateVariable(val);
    case "function":
      return "(" + val + ").call(" + this.generateVariable() + ", vars)";
  }
};

Context.prototype.generateError = function() {
  var args = Array.prototype.slice.call(arguments);
  var err = Context.interpolate.apply(this, args);

  if (this.isAsync) {
    this.pushCode(
      "return process.nextTick(function() { callback(new Error(" +
        err +
        "), vars); });"
    );
  } else {
    this.pushCode("throw new Error(" + err + ");");
  }
};

Context.prototype.generateTmpVariable = function() {
  return "$tmp" + this.tmpVariableCount++;
};

Context.prototype.pushCode = function() {
  var args = Array.prototype.slice.call(arguments);

  this.code += Context.interpolate.apply(this, args) + "\n";
};

Context.prototype.pushPath = function(name) {
  if (name) {
    this.scopes[this.scopes.length - 1].push(name);
  }
};

Context.prototype.popPath = function(name) {
  if (name) {
    this.scopes[this.scopes.length - 1].pop();
  }
};

Context.prototype.pushScope = function(name) {
  this.scopes.push([name]);
};

Context.prototype.popScope = function() {
  this.scopes.pop();
};

Context.prototype.addReference = function(alias) {
  if (this.references[alias]) return;
  this.references[alias] = { resolved: false, requested: false };
};

Context.prototype.markResolved = function(alias) {
  this.references[alias].resolved = true;
};

Context.prototype.markRequested = function(aliasList) {
  aliasList.forEach(
    function(alias) {
      this.references[alias].requested = true;
    }.bind(this)
  );
};

Context.prototype.getUnresolvedReferences = function() {
  var references = this.references;
  return Object.keys(this.references).filter(function(alias) {
    return !references[alias].resolved && !references[alias].requested;
  });
};

//----------------------------------------------------------------------------------------
// private methods
//----------------------------------------------------------------------------------------

Context.interpolate = function(s) {
  var re = /{\d+}/g;
  var matches = s.match(re);
  var params = Array.prototype.slice.call(arguments, 1);

  if (matches) {
    matches.forEach(function(match) {
      var index = parseInt(match.substr(1, match.length - 2), 10);
      s = s.replace(match, params[index].toString());
    });
  }

  return s;
};

exports.Context = Context;

},{}],6:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":3,"buffer":6,"ieee754":7}],7:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.THREE = {}));
}(this, function (exports) { 'use strict';

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		( function () {

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		} )();

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	var REVISION = '103';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var ACESFilmicToneMapping = 5;

	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: ( function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var lut = [];

			for ( var i = 0; i < 256; i ++ ) {

				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

			}

			return function generateUUID() {

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();

			};

		} )(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector2();
			var max = new Vector2();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( this.y, this.x );

			if ( angle < 0 ) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		isQuaternion: true,

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function ( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			var EPS = 0.000001;

			var r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		},

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				return this.normalize();

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function ( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		},

		unproject: function ( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		},

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		},

		setFromSphericalCoords: function ( radius, phi, theta ) {

			var sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		},

		setFromCylindricalCoords: function ( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix3( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var _canvas;

	var ImageUtils = {

		getDataURL: function ( image ) {

			var canvas;

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			} else if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				var context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		updateMatrix: function () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			var output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = _Math.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					var url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( var i = 0, l = image.length; i < l; i ++ ) {

							url.push( ImageUtils.getDataURL( image[ i ] ) );

						}

					} else {

						// process single image

						url = ImageUtils.getDataURL( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new Vector4();
					max = new Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author Matt DesLauriers / @mattdesl
	 */

	function WebGLMultisampleRenderTarget( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.samples = 4;

	}

	WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

		constructor: WebGLMultisampleRenderTarget,

		isWebGLMultisampleRenderTarget: true,

		copy: function ( source ) {

			WebGLRenderTarget.prototype.copy.call( this, source );

			this.samples = source.samples;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

	}

	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector3();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var scope, i, l;

			var v1 = new Vector3();

			function traverse( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			}

			return function expandByObject( object ) {

				scope = this;

				object.updateMatrixWorld( true );

				object.traverse( traverse );

				return this;

			};

		}(),

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: ( function () {

			var closestPoint = new Vector3();

			return function intersectsSphere( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			};

		} )(),

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		},

		intersectsTriangle: ( function () {

			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();

			var testAxis = new Vector3();

			var center = new Vector3();
			var extents = new Vector3();

			var triangleNormal = new Vector3();

			function satForAxes( axes ) {

				var i, j;

				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;

					}

				}

				return true;

			}

			return function intersectsTriangle( triangle ) {

				if ( this.isEmpty() ) {

					return false;

				}

				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );

				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );

				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );

			};

		} )(),

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector3();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new Vector3();

			return function getBoundingSphere( target ) {

				if ( target === undefined ) {

					console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
					//target = new Sphere(); // removed to avoid cyclic dependency

				}

				this.getCenter( target.center );

				target.radius = this.getSize( v1 ).length() * 0.5;

				return target;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3()
			];

			return function applyMatrix4( matrix ) {

				// transform of empty box is an empty box.
				if ( this.isEmpty() ) return this;

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new Box3();

			return function setFromPoints( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, target ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		},

		getBoundingBox: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function setFromCoplanarPoints( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function () {

			var v1 = new Vector3();

			return function intersectLine( line, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();

				}

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return target.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return target.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new Vector3();
			var m1 = new Matrix3();

			return function applyMatrix4( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new Sphere();

			return function intersectsObject( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSprite: function () {

			var sphere = new Sphere();

			return function intersectsSprite( sprite ) {

				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p = new Vector3();

			return function intersectsBox( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					// corner at max distance

					p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					if ( plane.distanceToPoint( p ) < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new Vector3();

			return function extractRotation( m ) {

				// this method does not support reflection matrices

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;

				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function () {

			var zero = new Vector3( 0, 0, 0 );
			var one = new Vector3( 1, 1, 1 );

			return function makeRotationFromQuaternion( q ) {

				return this.compose( zero, q, one );

			};

		}(),

		lookAt: function () {

			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();

			return function lookAt( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target );

				if ( z.lengthSq() === 0 ) {

					// eye and target are in the same position

					z.z = 1;

				}

				z.normalize();
				x.crossVectors( up, z );

				if ( x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						z.x += 0.0001;

					} else {

						z.z += 0.0001;

					}

					z.normalize();
					x.crossVectors( up, z );

				}

				x.normalize();
				y.crossVectors( z, x );

				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix4( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

		        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		        te[ 1 ] = ( xy + wz ) * sx;
		        te[ 2 ] = ( xz - wy ) * sx;
		        te[ 3 ] = 0;

		        te[ 4 ] = ( xy - wz ) * sy;
		        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		        te[ 6 ] = ( yz + wx ) * sy;
		        te[ 7 ] = 0;

		        te[ 8 ] = ( xz + wy ) * sz;
		        te[ 9 ] = ( yz - wx ) * sz;
		        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		        te[ 11 ] = 0;

		        te[ 12 ] = position.x;
		        te[ 13 ] = position.y;
		        te[ 14 ] = position.z;
		        te[ 15 ] = 1;

		        return this;

		},

		decompose: function () {

			var vector = new Vector3();
			var matrix = new Matrix4();

			return function decompose( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				matrix.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";

	var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";

	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		var dst = {};

		for ( var u in src ) {

			dst[ u ] = {};

			for ( var p in src[ u ] ) {

				var property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = cloneUniforms( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function setHSL( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function ( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		},

		convertLinearToGamma: function ( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		},

		copySRGBToLinear: function () {

			function SRGBToLinear( c ) {

				return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

			}

			return function copySRGBToLinear( color ) {

				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );

				return this;

			};

		}(),

		copyLinearToSRGB: function () {

			function LinearToSRGB( c ) {

				return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

			}

			return function copyLinearToSRGB( color ) {

				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );

				return this;

			};

		}(),

		convertSRGBToLinear: function () {

			this.copySRGBToLinear( this );

			return this;

		},

		convertLinearToSRGB: function () {

			this.copyLinearToSRGB( this );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function () {

			var hsl = {};

			return function ( h, s, l ) {

				this.getHSL( hsl );

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			};

		}(),

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		lerpHSL: function () {

			var hslA = { h: 0, s: 0, l: 0 };
			var hslB = { h: 0, s: 0, l: 0 };

			return function lerpHSL( color, alpha ) {

				this.getHSL( hslA );
				color.getHSL( hslB );

				var h = _Math.lerp( hslA.h, hslB.h, alpha );
				var s = _Math.lerp( hslA.s, hslB.s, alpha );
				var l = _Math.lerp( hslA.l, hslB.l, alpha );

				this.setHSL( h, s, l );

				return this;

			};

		}(),

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;

		function onAnimationFrame( time, frame ) {

			if ( isAnimating === false ) return;

			animationLoop( time, frame );

			context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl ) {

		var buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.dynamic ? 35048 : 35044;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = 5126;

			if ( array instanceof Float32Array ) {

				type = 5126;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = 5123;

			} else if ( array instanceof Int16Array ) {

				type = 5122;

			} else if ( array instanceof Uint32Array ) {

				type = 5125;

			} else if ( array instanceof Int32Array ) {

				type = 5124;

			} else if ( array instanceof Int8Array ) {

				type = 5120;

			} else if ( array instanceof Uint8Array ) {

				type = 5121;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( attribute.dynamic === false ) {

				gl.bufferData( bufferType, array, 35044 );

			} else if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else if ( updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = _Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix = new Matrix4();

			return function setFromQuaternion( q, order, update ) {

				matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( matrix, order, update );

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new Quaternion();

			return function reorder( newOrder ) {

				q.setFromEuler( this );

				return this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	var object3DId = 0;

	function Object3D() {

		Object.defineProperty( this, 'id', { value: object3DId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new Quaternion();

			return function rotateOnAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateOnWorldAxis: function () {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			var q1 = new Quaternion();

			return function rotateOnWorldAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function rotateX( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function rotateY( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function rotateZ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new Vector3();

			return function translateOnAxis( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function translateX( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function translateY( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function translateZ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new Matrix4();

			return function worldToLocal( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This method does not support objects having non-uniformly-scaled parent(s)

			var q1 = new Quaternion();
			var m1 = new Matrix4();
			var target = new Vector3();
			var position = new Vector3();

			return function lookAt( x, y, z ) {

				if ( x.isVector3 ) {

					target.copy( x );

				} else {

					target.set( x, y, z );

				}

				var parent = this.parent;

				this.updateWorldMatrix( true, false );

				position.setFromMatrixPosition( this.matrixWorld );

				if ( this.isCamera || this.isLight ) {

					m1.lookAt( position, target, this.up );

				} else {

					m1.lookAt( target, position, this.up );

				}

				this.quaternion.setFromRotationMatrix( m1 );

				if ( parent ) {

					m1.extractRotation( parent.matrixWorld );
					q1.setFromRotationMatrix( m1 );
					this.quaternion.premultiply( q1.inverse() );

				}

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new Vector3();
			var scale = new Vector3();

			return function getWorldQuaternion( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, target, scale );

				return target;

			};

		}(),

		getWorldScale: function () {

			var position = new Vector3();
			var quaternion = new Quaternion();

			return function getWorldScale( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, target );

				return target;

			};

		}(),

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			var e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		},

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			var parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {

		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

				scope.vertices.push( new Vector3().fromArray( positions, i ) );

				if ( colors !== undefined ) {

					scope.colors.push( new Color().fromArray( colors, i ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexColors = ( colors === undefined ) ? [] : [
					scope.colors[ a ].clone(),
					scope.colors[ b ].clone(),
					scope.colors[ c ].clone() ];

				var vertexNormals = ( normals === undefined ) ? [] : [
					new Vector3().fromArray( normals, a * 3 ),
					new Vector3().fromArray( normals, b * 3 ),
					new Vector3().fromArray( normals, c * 3 )
				];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [
						new Vector2().fromArray( uvs, a * 2 ),
						new Vector2().fromArray( uvs, b * 2 ),
						new Vector2().fromArray( uvs, c * 2 )
					] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [
						new Vector2().fromArray( uvs2, a * 2 ),
						new Vector2().fromArray( uvs2, b * 2 ),
						new Vector2().fromArray( uvs2, c * 2 )
					] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = source.morphTargets;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				this.morphTargets.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {

		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Object.assign( DirectGeometry.prototype, {

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex = undefined;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = {
						name: morphTargets[ i ].name,
					 	data: []
					};

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = {
						name: morphNormals[ i ].name,
					 	data: []
					};

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			if ( vertices.length > 0 && faces.length === 0 ) {

				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

			}

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		addAttribute: function ( name, attribute ) {

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return this;

			}

			this.attributes[ name ] = attribute;

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;

			}

			var tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				// Tangent is vec4, but the '.w' component is a sign value (+1/-1).
				normalMatrix.applyToBufferAttribute( tangent );
				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
					attribute.name = morphTarget.name;

					array.push( attribute.copyVector3sArray( morphTarget.data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			var box = new Box3();

			return function computeBoundingBox() {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var position = this.attributes.position;
				var morphAttributesPosition = this.morphAttributes.position;

				if ( position !== undefined ) {

					this.boundingBox.setFromBufferAttribute( position );

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							box.setFromBufferAttribute( morphAttribute );

							this.boundingBox.expandByPoint( box.min );
							this.boundingBox.expandByPoint( box.max );

						}

					}

				} else {

					this.boundingBox.makeEmpty();

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			};

		}(),

		computeBoundingSphere: function () {

			var box = new Box3();
			var boxMorphTargets = new Box3();
			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;
				var morphAttributesPosition = this.morphAttributes.position;

				if ( position ) {

					// first, find the center of the bounding sphere

					var center = this.boundingSphere.center;

					box.setFromBufferAttribute( position );

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							boxMorphTargets.setFromBufferAttribute( morphAttribute );

							box.expandByPoint( boxMorphTargets.min );
							box.expandByPoint( boxMorphTargets.max );

						}

					}

					box.getCenter( center );

					// second, try to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						vector.fromBufferAttribute( position, i );

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];

							for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

								vector.fromBufferAttribute( morphAttribute, i );

								maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

							}

						}

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					for ( var i = 0, il = index.count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var vector = new Vector3();

			return function normalizeNormals() {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );

					vector.normalize();

					normals.setXYZ( i, vector.x, vector.y, vector.z );

				}

			};

		}(),

		toNonIndexed: function () {

			function convertBufferAttribute( attribute, indices ) {

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			// attributes

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.addAttribute( name, newAttribute );

			}

			// morph attributes

			var morphAttributes = this.morphAttributes;

			for ( name in morphAttributes ) {

				var morphArray = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

					var attribute = morphAttribute[ i ];

					var newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			// groups

			var groups = this.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var attributeData = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: Array.prototype.slice.call( attribute.array ),
					normalized: attribute.normalized
				};

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				data.data.attributes[ key ] = attributeData;

			}

			var morphAttributes = {};
			var hasMorphAttributes = false;

			for ( var key in this.morphAttributes ) {

				var attributeArray = this.morphAttributes[ key ];

				var array = [];

				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

					var attribute = attributeArray[ i ];

					var attributeData = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: Array.prototype.slice.call( attribute.array ),
						normalized: attribute.normalized
					};

					if ( attribute.name !== '' ) attributeData.name = attribute.name;

					array.push( attributeData );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) data.data.morphAttributes = morphAttributes;

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		BufferGeometry.call( this );

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

		Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexTangents = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

				if ( this.combine !== undefined ) data.combine = this.combine;
				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;

			this.shadowSide = source.shadowSide;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = {};

		for ( var name in this.uniforms ) {

			var uniform = this.uniforms[ name ];
			var value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		var extensions = {};

		for ( var key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();

	}

	Object.assign( Ray.prototype, {

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		lookAt: function ( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		},

		recast: function () {

			var v1 = new Vector3();

			return function recast( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			target.subVectors( point, this.origin );

			var directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new Vector3();

			return function distanceSqToPoint( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();

			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new Vector3();

			return function intersectSphere( sphere, target ) {

				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, target );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function ( plane, target ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		},

		intersectsPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function ( box, target ) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		},

		intersectsBox: ( function () {

			var v = new Vector3();

			return function intersectsBox( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		} )(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();

			return function intersectTriangle( a, b, c, backfaceCulling, target ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, target );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		getNormal: function () {

			var v0 = new Vector3();

			return function getNormal( a, b, c, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();

				}

				target.subVectors( c, b );
				v0.subVectors( a, b );
				target.cross( v0 );

				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq > 0 ) {

					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

				}

				return target.set( 0, 0, 0 );

			};

		}(),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function getBarycoord( point, a, b, c, target ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();

				}

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );

			};

		}(),

		containsPoint: function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				Triangle.getBarycoord( point, a, b, c, v1 );

				return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

			};

		}(),

		getUV: function () {

			var barycoord = new Vector3();

			return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

				this.getBarycoord( point, p1, p2, p3, barycoord );

				target.set( 0, 0 );
				target.addScaledVector( uv1, barycoord.x );
				target.addScaledVector( uv2, barycoord.y );
				target.addScaledVector( uv3, barycoord.z );

				return target;

			};

		}()

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		getArea: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();

			return function getArea() {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		getMidpoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		getNormal: function ( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		},

		getPlane: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Vector3();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		getBarycoord: function ( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		getUV: function ( point, uv1, uv2, uv3, result ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );

		},

		intersectsBox: function ( box ) {

			return box.intersectsTriangle( this );

		},

		closestPointToPoint: function () {

			var vab = new Vector3();
			var vac = new Vector3();
			var vbc = new Vector3();
			var vap = new Vector3();
			var vbp = new Vector3();
			var vcp = new Vector3();

			return function closestPointToPoint( p, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				var a = this.a, b = this.b, c = this.c;
				var v, w;

				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.

				vab.subVectors( b, a );
				vac.subVectors( c, a );
				vap.subVectors( p, a );
				var d1 = vab.dot( vap );
				var d2 = vac.dot( vap );
				if ( d1 <= 0 && d2 <= 0 ) {

					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy( a );

				}

				vbp.subVectors( p, b );
				var d3 = vab.dot( vbp );
				var d4 = vac.dot( vbp );
				if ( d3 >= 0 && d4 <= d3 ) {

					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy( b );

				}

				var vc = d1 * d4 - d3 * d2;
				if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

					v = d1 / ( d1 - d3 );
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy( a ).addScaledVector( vab, v );

				}

				vcp.subVectors( p, c );
				var d5 = vab.dot( vcp );
				var d6 = vac.dot( vcp );
				if ( d6 >= 0 && d5 <= d6 ) {

					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy( c );

				}

				var vb = d5 * d2 - d1 * d6;
				if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

					w = d2 / ( d2 - d6 );
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy( a ).addScaledVector( vac, w );

				}

				var va = d3 * d6 - d5 * d4;
				if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

					vbc.subVectors( c, b );
					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC

				}

				// face region
				var denom = 1 / ( va + vb + vc );
				// u = va * denom
				v = vb * denom;
				w = vc * denom;
				return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );

			};

		}(),

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode: function ( value ) {

			this.drawMode = value;

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.drawMode = source.drawMode;

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		},

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();

			var morphA = new Vector3();
			var morphB = new Vector3();
			var morphC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();

			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

				var intersect;

				if ( material.side === BackSide ) {

					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

				} else {

					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

				}

				if ( intersect === null ) return null;

				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

				if ( distance < raycaster.near || distance > raycaster.far ) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, uv, a, b, c ) {

				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );

				var morphInfluences = object.morphTargetInfluences;

				if ( material.morphTargets && morphPosition && morphInfluences ) {

					morphA.set( 0, 0, 0 );
					morphB.set( 0, 0, 0 );
					morphC.set( 0, 0, 0 );

					for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

						var influence = morphInfluences[ i ];
						var morphAttribute = morphPosition[ i ];

						if ( influence === 0 ) continue;

						tempA.fromBufferAttribute( morphAttribute, a );
						tempB.fromBufferAttribute( morphAttribute, b );
						tempC.fromBufferAttribute( morphAttribute, c );

						morphA.addScaledVector( tempA.sub( vA ), influence );
						morphB.addScaledVector( tempB.sub( vB ), influence );
						morphC.addScaledVector( tempC.sub( vC ), influence );

					}

					vA.add( morphA );
					vB.add( morphB );
					vC.add( morphC );

				}

				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

				if ( intersection ) {

					if ( uv ) {

						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );

						intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );

					}

					var face = new Face3( a, b, c );
					Triangle.getNormal( vA, vB, vC, face.normal );

					intersection.face = face;

				}

				return intersection;

			}

			return function raycast( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) return;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var morphPosition = geometry.morphAttributes.position;
					var uv = geometry.attributes.uv;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;

					if ( index !== null ) {

						// indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = index.getX( j );
									b = index.getX( j + 1 );
									c = index.getX( j + 2 );

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = j;
									b = j + 1;
									c = j + 2;

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) continue;

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );

								intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeMesh;
		var boxMesh;
		// Store the current background texture and its `version`
		// so we can recompile the material accordingly.
		var currentBackground = null;
		var currentBackgroundVersion = 0;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			// Ignore background in AR
			// TODO: Reconsider this.

			var vr = renderer.vr;
			var session = vr.getSession && vr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );
				currentBackground = null;
				currentBackgroundVersion = 0;

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;
				currentBackground = null;
				currentBackgroundVersion = 0;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							type: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'map', {

						get: function () {

							return this.uniforms.tCube.value;

						}

					} );

					objects.update( boxMesh );

				}

				var texture = background.isWebGLRenderTargetCube ? background.texture : background;
				boxMesh.material.uniforms.tCube.value = texture;
				boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;

				if ( currentBackground !== background ||
				     currentBackgroundVersion !== texture.version ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = texture.version;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new ShaderMaterial( {
							type: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.removeAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					   currentBackgroundVersion !== background.version ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension;

			if ( capabilities.isWebGL2 ) {

				extension = gl;

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				     gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				     gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( 34930 );
		var maxVertexTextures = gl.getParameter( 35660 );
		var maxTextureSize = gl.getParameter( 3379 );
		var maxCubemapSize = gl.getParameter( 34076 );

		var maxAttributes = gl.getParameter( 34921 );
		var maxVertexUniforms = gl.getParameter( 36347 );
		var maxVaryings = gl.getParameter( 36348 );
		var maxFragmentUniforms = gl.getParameter( 36349 );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;

			return dstArray;

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, info ) {

		var geometries = {};
		var wireframeAttributes = {};

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var attribute = wireframeAttributes[ buffergeometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, 34963 );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], 34962 );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], 34962 );

				}

			}

		}

		function getWireframeAttribute( geometry ) {

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) return attribute;

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryAttributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

			attributes.update( attribute, 34963 );

			wireframeAttributes[ geometry.id ] = attribute;

			return attribute;

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension;

			if ( capabilities.isWebGL2 ) {

				extension = gl;

			} else {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLInfo( gl ) {

		var memory = {
			geometries: 0,
			textures: 0
		};

		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			instanceCount = instanceCount || 1;

			render.calls ++;

			switch ( mode ) {

				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case 5:
				case 6:
					render.triangles += instanceCount * ( count - 2 );
					break;

				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;

				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			var length = objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {

					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {

						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( geometries, info ) {

		var updateList = {};

		function update( object ) {

			var frame = info.render.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateList[ buffergeometry.id ] !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateList[ buffergeometry.id ] = frame;

			}

			return buffergeometry;

		}

		function dispose() {

			updateList = {};

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		format = format !== undefined ? format : RGBFormat;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	/**
	 * @author Takahiro https://github.com/takahirox
	 */

	function DataTexture2DArray( data, width, height, depth ) {

		Texture.call( this, null );

		this.image = { data: data, width: width, height: height, depth: depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

	}

	DataTexture2DArray.prototype = Object.create( Texture.prototype );
	DataTexture2DArray.prototype.constructor = DataTexture2DArray;
	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	/**
	 * @author Artur Trzesiok
	 */

	function DataTexture3D( data, width, height, depth ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	var texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		Texture.call( this, null );

		this.image = { data: data, width: width, height: height, depth: depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

	}

	DataTexture3D.prototype = Object.create( Texture.prototype );
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( var i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( var i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = textures.allocateTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValue1i( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue3fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue4fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValue3fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValue4fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTexture2D( v || emptyTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || emptyTexture3d, unit );

	}

	function setValueT6( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue3iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue4iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4

			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4

			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8b5f: return setValueT3D1; // SAMPLER_3D
			case 0x8b60: return setValueT6; // SAMPLER_CUBE
			case 0x8DC1: return setValueT2DArray1; // SAMPLER_2D_ARRAY

			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// Array of scalars

	function setValue1fv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1fv( this.addr, v );

		copyArray( cache, v );

	}
	function setValue1iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1iv( this.addr, v );

		copyArray( cache, v );

	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 2 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform2fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 3 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform3fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform4fv( this.addr, data );

		this.updateCache( data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix2fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 9 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix3fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 16 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix4fv( this.addr, false, data );

		this.updateCache( data );

	}

	// Array of textures (2D / Cube)

	function setValueT1a( gl, v, textures ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( textures, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6a( gl, v, textures ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( textures, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4

			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4

			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		var cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		var n = gl.getProgramParameter( program, 35718 );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, 35713 ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, 35721 );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	function parseIncludes( string ) {

		var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

		function replace( match, include ) {

			var replace = ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities, textures ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
					ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {

			var isGLSL3ShaderMaterial = false;

			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

			if ( material.isShaderMaterial &&
				vertexShader.match( versionRegex ) !== null &&
				fragmentShader.match( versionRegex ) !== null ) {

				isGLSL3ShaderMaterial = true;

				vertexShader = vertexShader.replace( versionRegex, '' );
				fragmentShader = fragmentShader.replace( versionRegex, '' );

			}

			// GLSL 3.0 conversion
			prefixVertex = [
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program, textures );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.name = shader.name;
		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities, textures ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];


		function allocateBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( capabilities.floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

				encoding = GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				combine: material.combine,

				vertexTangents: ( material.normalMap && material.vertexTangents ),
				vertexColors: material.vertexColors,

				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( material.fragmentShader );
				array.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					array.push( name );
					array.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( material.onBeforeCompile.toString() );

			array.push( renderer.gammaOutput );

			array.push( renderer.gammaFactor );

			return array.join();

		};

		this.acquireProgram = function ( material, shader, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities, textures );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = new WeakMap();

		function get( object ) {

			var map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		var defaultProgram = { id: - 1 };

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).push( renderItem );

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

		}

		function sort() {

			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = {};

		function onSceneDispose( event ) {

			var scene = event.target;

			scene.removeEventListener( 'dispose', onSceneDispose );

			delete lists[ scene.id ];

		}

		function get( scene, camera ) {

			var cameras = lists[ scene.id ];
			var list;
			if ( cameras === undefined ) {

				list = new WebGLRenderList();
				lists[ scene.id ] = {};
				lists[ scene.id ][ camera.id ] = list;

				scene.addEventListener( 'dispose', onSceneDispose );

			} else {

				list = cameras[ camera.id ];
				if ( list === undefined ) {

					list = new WebGLRenderList();
					cameras[ camera.id ] = list;

				}

			}

			return list;

		}

		function dispose() {

			lists = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	var count = 0;

	function WebGLLights() {

		var cache = new UniformsCache();

		var state = {

			id: count ++,

			hash: {
				stateID: - 1,
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,
				shadowsLength: - 1
			},

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;

					}

					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms = cache.get( light );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.hash.stateID = state.id;
			state.hash.directionalLength = directionalLength;
			state.hash.pointLength = pointLength;
			state.hash.spotLength = spotLength;
			state.hash.rectAreaLength = rectAreaLength;
			state.hash.hemiLength = hemiLength;
			state.hash.shadowsLength = shadows.length;

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {

		var lights = new WebGLLights();

		var lightsArray = [];
		var shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( camera ) {

			lights.setup( lightsArray, shadowsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates() {

		var renderStates = {};

		function onSceneDispose( event ) {

			var scene = event.target;

			scene.removeEventListener( 'dispose', onSceneDispose );

			delete renderStates[ scene.id ];

		}

		function get( scene, camera ) {

			var renderState;

			if ( renderStates[ scene.id ] === undefined ) {

				renderState = new WebGLRenderState();
				renderStates[ scene.id ] = {};
				renderStates[ scene.id ][ camera.id ] = renderState;

				scene.addEventListener( 'dispose', onSceneDispose );

			} else {

				if ( renderStates[ scene.id ][ camera.id ] === undefined ) {

					renderState = new WebGLRenderState();
					renderStates[ scene.id ][ camera.id ] = renderState;

				} else {

					renderState = renderStates[ scene.id ][ camera.id ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];

		// init

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ i ] = depthMaterial;

			//

			var distanceMaterial = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			var currentRenderTarget = _renderer.getRenderTarget();

			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			var faceCount;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );

				if ( isPointLight ) {

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				}

				if ( shadow.map === null ) {

					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";

					shadowCamera.updateProjectionMatrix();

				}

				if ( shadow.isSpotLightShadow ) {

					shadow.update( light );

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				if ( isPointLight ) {

					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

				} else {

					faceCount = 1;

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				}

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();

						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );

					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					renderObject( scene, camera, shadowCamera, isPointLight );

				}

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget );

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = false;

				if ( material.morphTargets ) {

					if ( geometry && geometry.isBufferGeometry ) {

						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

					} else if ( geometry && geometry.isGeometry ) {

						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

					}

				}

				if ( object.isSkinnedMesh && material.skinning === false ) {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

				var useSkinning = object.isSkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				result = materialVariants[ variantIndex ];

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( isPointLight && result.isMeshDistanceMaterial ) {

				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, isPointLight ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, isPointLight );

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, utils, capabilities ) {

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( 2929 );

					} else {

						disable( 2929 );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( 512 );
									break;

								case AlwaysDepth:

									gl.depthFunc( 519 );
									break;

								case LessDepth:

									gl.depthFunc( 513 );
									break;

								case LessEqualDepth:

									gl.depthFunc( 515 );
									break;

								case EqualDepth:

									gl.depthFunc( 514 );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( 518 );
									break;

								case GreaterDepth:

									gl.depthFunc( 516 );
									break;

								case NotEqualDepth:

									gl.depthFunc( 517 );
									break;

								default:

									gl.depthFunc( 515 );

							}

						} else {

							gl.depthFunc( 515 );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( 34921 );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var enabledCapabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( 35661 );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( 7938 );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );

		setBlending( NoBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function getCompressedTextureFormats() {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

					var formats = gl.getParameter( 34467 );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled ) {

					disable( 3042 );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( ! currentBlendingEnabled ) {

				enable( 3042 );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( 32774 );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 0, 769, 771 );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFunc( 0, 769 );
								break;

							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( 2304 );

				} else {

					gl.frontFace( 2305 );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( 2884 );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( 1029 );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( 1028 );

					} else {

						gl.cullFace( 1032 );

					}

				}

			} else {

				disable( 2884 );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( 32823 );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( 32823 );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( 3089 );

			} else {

				disable( 3089 );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			enabledCapabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		var _videoTextures = {};
		var _canvas;

		//

		var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas( width, height ) :
				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			var scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;

					var width = floor( scale * image.width );
					var height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( capabilities.isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			var textureProperties = properties.get( texture );

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

		}

		function getInternalFormat( glFormat, glType ) {

			if ( ! capabilities.isWebGL2 ) return glFormat;

			var internalFormat = glFormat;

			if ( glFormat === 6403 ) {

				if ( glType === 5126 ) internalFormat = 33326;
				if ( glType === 5131 ) internalFormat = 33325;
				if ( glType === 5121 ) internalFormat = 33321;

			}

			if ( glFormat === 6407 ) {

				if ( glType === 5126 ) internalFormat = 34837;
				if ( glType === 5131 ) internalFormat = 34843;
				if ( glType === 5121 ) internalFormat = 32849;

			}

			if ( glFormat === 6408 ) {

				if ( glType === 5126 ) internalFormat = 34836;
				if ( glType === 5131 ) internalFormat = 34842;
				if ( glType === 5121 ) internalFormat = 32856;

			}

			if ( internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 34842 || internalFormat === 34836 ) {

				extensions.get( 'EXT_color_buffer_float' );

			} else if ( internalFormat === 34843 || internalFormat === 34837 ) {

				console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );

			}

			return internalFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

				return 9728;

			}

			return 9729;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				delete _videoTextures[ texture.id ];

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//

		var textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			var textureUnit = textureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		//

		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 3553, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 35866, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					initTexture( textureProperties, texture );

					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__webglTexture );

					_gl.pixelStorei( 37440, texture.flipY );

					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type ),
						glInternalFormat = getInternalFormat( glFormat, glType );

					setTextureParameters( 34067, texture, supportsMips );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( ! isCompressed ) {

						textureProperties.__maxMipLevel = 0;

					} else {

						textureProperties.__maxMipLevel = mipmaps.length - 1;

					}

					if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

						// We assume images for cube map have the same size.
						generateMipmap( 34067, texture, image.width, image.height );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__webglTexture );

				}

			}

		}

		function setTextureCubeDynamic( texture, slot ) {

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, properties.get( texture ).__webglTexture );

		}

		function setTextureParameters( textureType, texture, supportsMips ) {

			var extension;

			if ( supportsMips ) {

				_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) );

				}

				_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, 33071 );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			var textureType = 3553;

			if ( texture.isDataTexture2DArray ) textureType = 35866;
			if ( texture.isDataTexture3D ) textureType = 32879;

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );

			var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );

			var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( glFormat, glType );

			setTextureParameters( textureType, texture, supportsMips );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( texture.type === FloatType ) {

					if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					glInternalFormat = 36012;

				} else if ( capabilities.isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = 33189;

				}

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else if ( texture.isDataTexture2DArray ) {

				state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else if ( texture.isDataTexture3D ) {

				state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 3553, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( 36160, framebuffer );
			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( 36160, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( 36161, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

			} else {

				var glFormat = utils.convert( renderTarget.texture.format );
				var glType = utils.convert( renderTarget.texture.type );
				var glInternalFormat = getInternalFormat( glFormat, glType );

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( 36161, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( 36160, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

					}

				} else {

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( 36160, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultisample ) {

					if ( capabilities.isWebGL2 ) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );
						var glFormat = utils.convert( renderTarget.texture.format );
						var glType = utils.convert( renderTarget.texture.type );
						var glInternalFormat = getInternalFormat( glFormat, glType );
						var samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( 36161, null );

						if ( renderTarget.depthBuffer ) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

						}

						_gl.bindFramebuffer( 36160, null );


					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( 34067, textureProperties.__webglTexture );
				setTextureParameters( 34067, renderTarget.texture, supportsMips );

				for ( var i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 34067, null );

			} else {

				state.bindTexture( 3553, textureProperties.__webglTexture );
				setTextureParameters( 3553, renderTarget.texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 3553, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				if ( capabilities.isWebGL2 ) {

					var renderTargetProperties = properties.get( renderTarget );

					_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = 16384;

					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;

		}

		function updateVideoTexture( texture ) {

			var id = texture.id;
			var frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures[ id ] !== frame ) {

				_videoTextures[ id ] = frame;
				texture.update();

			}

		}

		// backwards compatibility

		var warnedTexture2D = false;
		var warnedTextureCube = false;

		function safeSetTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( warnedTexture2D === false ) {

					console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warnedTexture2D = true;

				}

				texture = texture.texture;

			}

			setTexture2D( texture, slot );

		}

		function safeSetTextureCube( texture, slot ) {

			if ( texture && texture.isWebGLRenderTargetCube ) {

				if ( warnedTextureCube === false ) {

					console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warnedTextureCube = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube
				setTextureCubeDynamic( texture, slot );

			}

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions, capabilities ) {

		function convert( p ) {

			var extension;

			if ( p === RepeatWrapping ) return 10497;
			if ( p === ClampToEdgeWrapping ) return 33071;
			if ( p === MirroredRepeatWrapping ) return 33648;

			if ( p === NearestFilter ) return 9728;
			if ( p === NearestMipMapNearestFilter ) return 9984;
			if ( p === NearestMipMapLinearFilter ) return 9986;

			if ( p === LinearFilter ) return 9729;
			if ( p === LinearMipMapNearestFilter ) return 9985;
			if ( p === LinearMipMapLinearFilter ) return 9987;

			if ( p === UnsignedByteType ) return 5121;
			if ( p === UnsignedShort4444Type ) return 32819;
			if ( p === UnsignedShort5551Type ) return 32820;
			if ( p === UnsignedShort565Type ) return 33635;

			if ( p === ByteType ) return 5120;
			if ( p === ShortType ) return 5122;
			if ( p === UnsignedShortType ) return 5123;
			if ( p === IntType ) return 5124;
			if ( p === UnsignedIntType ) return 5125;
			if ( p === FloatType ) return 5126;

			if ( p === HalfFloatType ) {

				if ( capabilities.isWebGL2 ) return 5131;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) return extension.HALF_FLOAT_OES;

			}

			if ( p === AlphaFormat ) return 6406;
			if ( p === RGBFormat ) return 6407;
			if ( p === RGBAFormat ) return 6408;
			if ( p === LuminanceFormat ) return 6409;
			if ( p === LuminanceAlphaFormat ) return 6410;
			if ( p === DepthFormat ) return 6402;
			if ( p === DepthStencilFormat ) return 34041;
			if ( p === RedFormat ) return 6403;

			if ( p === AddEquation ) return 32774;
			if ( p === SubtractEquation ) return 32778;
			if ( p === ReverseSubtractEquation ) return 32779;

			if ( p === ZeroFactor ) return 0;
			if ( p === OneFactor ) return 1;
			if ( p === SrcColorFactor ) return 768;
			if ( p === OneMinusSrcColorFactor ) return 769;
			if ( p === SrcAlphaFactor ) return 770;
			if ( p === OneMinusSrcAlphaFactor ) return 771;
			if ( p === DstAlphaFactor ) return 772;
			if ( p === OneMinusDstAlphaFactor ) return 773;

			if ( p === DstColorFactor ) return 774;
			if ( p === OneMinusDstColorFactor ) return 775;
			if ( p === SrcAlphaSaturateFactor ) return 776;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					return p;

				}

			}

			if ( p === MinEquation || p === MaxEquation ) {

				if ( capabilities.isWebGL2 ) {

					if ( p === MinEquation ) return 32775;
					if ( p === MaxEquation ) return 32776;

				}

				extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( capabilities.isWebGL2 ) return 34042;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

			}

			return 0;

		}

		return { convert: convert };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			var e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera( array ) {

		PerspectiveCamera.call( this );

		this.cameras = array || [];

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/**
	 * @author jsantell / https://www.jsantell.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var cameraLPos = new Vector3();
	var cameraRPos = new Vector3();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		var ipd = cameraLPos.distanceTo( cameraRPos );

		var projL = cameraL.projectionMatrix.elements;
		var projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		var left = near * leftFov;
		var right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		var zOffset = ipd / ( - leftFov + rightFov );
		var xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		var near2 = near + zOffset;
		var far2 = far + zOffset;
		var left2 = left - xOffset;
		var right2 = right + ( ipd - xOffset );
		var top2 = topFov * far / far2 * near2;
		var bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager( renderer ) {

		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		var controllers = [];
		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();

		var framebufferScaleFactor = 1.0;

		var frameOfReferenceType = 'stage';

		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

			frameData = new window.VRFrameData();
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

		}

		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();

		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );

		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		function isPresenting() {

			return device !== null && device.isPresenting === true;

		}

		var currentSize = new Vector2(), currentPixelRatio;

		function onVRDisplayPresentChange() {

			if ( isPresenting() ) {

				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
				var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

				currentPixelRatio = renderer.getPixelRatio();
				renderer.getSize( currentSize );

				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

				animation.start();

			} else {

				if ( scope.enabled ) {

					renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

				}

				animation.stop();

			}

		}

		//

		var triggers = [];

		function findGamepad( id ) {

			var gamepads = navigator.getGamepads && navigator.getGamepads();

			for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

				var gamepad = gamepads[ i ];

				if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

					if ( j === id ) return gamepad;

					j ++;

				}

			}

		}

		function updateControllers() {

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var gamepad = findGamepad( i );

				if ( gamepad !== undefined && gamepad.pose !== undefined ) {

					if ( gamepad.pose === null ) return;

					//  Pose

					var pose = gamepad.pose;

					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );

					if ( pose.position !== null ) controller.position.fromArray( pose.position );
					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
					controller.matrix.premultiply( standingMatrix );
					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;

					//  Trigger

					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

					if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {

						triggers[ i ] = gamepad.buttons[ buttonId ].pressed;

						if ( triggers[ i ] === true ) {

							controller.dispatchEvent( { type: 'selectstart' } );

						} else {

							controller.dispatchEvent( { type: 'selectend' } );
							controller.dispatchEvent( { type: 'select' } );

						}

					}

				} else {

					controller.visible = false;

				}

			}

		}

		//

		this.enabled = false;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

			animation.setContext( value );

		};

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

		};

		this.setFrameOfReferenceType = function ( value ) {

			frameOfReferenceType = value;

		};

		this.setPoseTarget = function ( object ) {

			if ( object !== undefined ) poseTarget = object;

		};

		this.getCamera = function ( camera ) {

			var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

			if ( isPresenting() === false ) {

				camera.position.set( 0, userHeight, 0 );
				camera.rotation.set( 0, 0, 0 );

				return camera;

			}

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData( frameData );

			//

			if ( frameOfReferenceType === 'stage' ) {

				var stageParameters = device.stageParameters;

				if ( stageParameters ) {

					standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

				} else {

					standingMatrix.makeTranslation( 0, userHeight, 0 );

				}

			}


			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;

			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

			if ( pose.orientation !== null ) {

				tempQuaternion.fromArray( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );

			}

			if ( pose.position !== null ) {

				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );

			}

			poseObject.updateMatrixWorld();

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

			// TODO (mrdoob) Double check this code

			standingMatrixInverse.getInverse( standingMatrix );

			if ( frameOfReferenceType === 'stage' ) {

				cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
				cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

			}

			var parent = poseObject.parent;

			if ( parent !== null ) {

				matrixWorldInverse.getInverse( parent.matrixWorld );

				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

			//

			var layers = device.getLayers();

			if ( layers.length ) {

				var layer = layers[ 0 ];

				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

					cameraL.bounds.fromArray( layer.leftBounds );

				}

				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

					cameraR.bounds.fromArray( layer.rightBounds );

				}

			}

			updateControllers();

			return cameraVR;

		};

		this.getStandingMatrix = function () {

			return standingMatrix;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var animation = new WebGLAnimation();

		this.setAnimationLoop = function ( callback ) {

			animation.setAnimationLoop( callback );

			if ( isPresenting() ) animation.start();

		};

		this.submitFrame = function () {

			if ( isPresenting() ) device.submitFrame();

		};

		this.dispose = function () {

			if ( typeof window !== 'undefined' ) {

				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebXRManager( renderer ) {

		var gl = renderer.context;

		var device = null;
		var session = null;

		var framebufferScaleFactor = 1.0;

		var frameOfReference = null;
		var frameOfReferenceType = 'stage';

		var pose = null;

		var controllers = [];
		var inputSources = [];

		function isPresenting() {

			return session !== null && frameOfReference !== null;

		}

		//

		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		this.enabled = false;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;
			if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );

		};

		//

		function onSessionEvent( event ) {

			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
			if ( controller ) controller.dispatchEvent( { type: event.type } );

		}

		function onSessionEnd() {

			renderer.setFramebuffer( null );
			renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
			animation.stop();

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

		};

		this.setFrameOfReferenceType = function ( value ) {

			frameOfReferenceType = value;

		};

		this.setSession = function ( value ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );

				session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );
				session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {

					frameOfReference = value;

					renderer.setFramebuffer( session.baseLayer.framebuffer );

					animation.setContext( session );
					animation.start();

				} );

				//

				inputSources = session.getInputSources();

				session.addEventListener( 'inputsourceschange', function () {

					inputSources = session.getInputSources();
					console.log( inputSources );

					for ( var i = 0; i < controllers.length; i ++ ) {

						var controller = controllers[ i ];
						controller.userData.inputSource = inputSources[ i ];

					}

				} );

			}

		};

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		}

		this.getCamera = function ( camera ) {

			if ( isPresenting() ) {

				var parent = camera.parent;
				var cameras = cameraVR.cameras;

				updateCamera( cameraVR, parent );

				for ( var i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update camera and its children

				camera.matrixWorld.copy( cameraVR.matrixWorld );

				var children = camera.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

				return cameraVR;

			}

			return camera;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getDevicePose( frameOfReference );

			if ( pose !== null ) {

				var layer = session.baseLayer;
				var views = frame.views;

				for ( var i = 0; i < views.length; i ++ ) {

					var view = views[ i ];
					var viewport = layer.getViewport( view );
					var viewMatrix = pose.getViewMatrix( view );

					var camera = cameraVR.cameras[ i ];
					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

				}

			}

			//

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var inputSource = inputSources[ i ];

				if ( inputSource ) {

					var inputPose = frame.getInputPose( inputSource, frameOfReference );

					if ( inputPose !== null ) {

						if ( 'targetRay' in inputPose ) {

							controller.matrix.elements = inputPose.targetRay.transformMatrix;

						} else if ( 'pointerMatrix' in inputPose ) {

							// DEPRECATED

							controller.matrix.elements = inputPose.pointerMatrix;

						}

						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
						controller.visible = true;

						continue;

					}

				}

				controller.visible = false;

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

		// DEPRECATED

		this.getStandingMatrix = function () {

			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
			return new Matrix4();

		};

		this.submitFrame = function () {};

	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		console.log( 'THREE.WebGLRenderer', REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		var currentRenderList = null;
		var currentRenderState = null;

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_framebuffer = null,

			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,

			// geometry and program caching

			_currentGeometryProgram = {
				geometry: null,
				program: null,
				wireframe: false
			},

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3();

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			if ( ! capabilities.isWebGL2 ) {

				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'ANGLE_instanced_arrays' );

			}

			extensions.get( 'OES_texture_float_linear' );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, utils, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( geometries, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities, textures );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// vr

		var vr = null;

		if ( typeof navigator !== 'undefined' ) {

			vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

		}

		this.vr = vr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( vr.isPresenting() ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width * _pixelRatio, _height * _pixelRatio );

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

				target = new Vector4();

			}

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= 16384;
			if ( depth === undefined || depth ) bits |= 256;
			if ( stencil === undefined || stencil ) bits |= 1024;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			vr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( 34962, buffers.position );
				_gl.bufferData( 34962, object.positionArray, 35048 );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( 34962, buffers.normal );
				_gl.bufferData( 34962, object.normalArray, 35048 );

				state.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( 34962, buffers.uv );
				_gl.bufferData( 34962, object.uvArray, 35048 );

				state.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( 34962, buffers.color );
				_gl.bufferData( 34962, object.colorArray, 35048 );

				state.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( 4, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			state.setMaterial( material, frontFaceCW );

			var program = setProgram( camera, fog, material, object );

			var updateBuffers = false;

			if ( _currentGeometryProgram.geometry !== geometry.id ||
				_currentGeometryProgram.program !== program.id ||
				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;

			}

			if ( object.morphTargetInfluences ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( 34963, attribute.buffer );

				}

			}

			//

			var dataCount = Infinity;

			if ( index !== null ) {

				dataCount = index.count;

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );

				} else {

					switch ( object.drawMode ) {

						case TrianglesDrawMode:
							renderer.setMode( 4 );
							break;

						case TriangleStripDrawMode:
							renderer.setMode( 5 );
							break;

						case TriangleFanDrawMode:
							renderer.setMode( 6 );
							break;

					}

				}


			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( 1 );

				} else if ( object.isLineLoop ) {

					renderer.setMode( 2 );

				} else {

					renderer.setMode( 3 );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( 0 );

			} else if ( object.isSprite ) {

				renderer.setMode( 4 );

			}

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry, drawStart, drawCount );

				}

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry ) {

			if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.traverse( function ( object ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( camera );

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							initMaterial( object.material[ i ], scene.fog, object );

						}

					} else {

						initMaterial( object.material, scene.fog, object );

					}

				}

			} );

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( vr.isPresenting() ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			vr.setAnimationLoop( callback );

			animation.start();

		};

		// Rendering

		this.render = function ( scene, camera ) {

			var renderTarget, forceClear;

			if ( arguments[ 2 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
				renderTarget = arguments[ 2 ];

			}

			if ( arguments[ 3 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
				forceClear = arguments[ 3 ];

			}

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( vr.enabled ) {

				camera = vr.getCamera( camera );

			}

			//

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, 0, _this.sortObjects );

			if ( _this.sortObjects === true ) {

				currentRenderList.sort();

			}

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights( camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			if ( this.info.autoReset ) this.info.reset();

			if ( renderTarget !== undefined ) {

				this.setRenderTarget( renderTarget );

			}

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			//

			scene.onAfterRender( _this, scene, camera );

			//

			if ( _currentRenderTarget !== null ) {

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			if ( vr.enabled ) {

				vr.submitFrame();

			}

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						object.skeleton.update();

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							if ( 'viewport' in camera2 ) { // XR

								state.viewport( _currentViewport.copy( camera2.viewport ) );

							} else {

								var bounds = camera2.bounds;

								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;

								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

							}

							currentRenderState.setupLights( camera2 );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				state.setMaterial( material );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		}

		function initMaterial( material, fog, object ) {

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;

			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
				lightsHash.pointLength !== lightsStateHash.pointLength ||
				lightsHash.spotLength !== lightsStateHash.spotLength ||
				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {

				lightsHash.stateID = lightsStateHash.stateID;
				lightsHash.directionalLength = lightsStateHash.directionalLength;
				lightsHash.pointLength = lightsStateHash.pointLength;
				lightsHash.spotLength = lightsStateHash.spotLength;
				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
				lightsHash.hemiLength = lightsStateHash.hemiLength;
				lightsHash.shadowsLength = lightsStateHash.shadowsLength;

				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = ShaderLib[ parameters.shaderID ];

					materialProperties.shader = {
						name: material.type,
						uniforms: cloneUniforms( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.onBeforeCompile( materialProperties.shader, _this );

				// Computing code again as onBeforeCompile may have changed the shaders
				code = programCache.getProgramCode( material, parameters );

				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.shader.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = fog;

			// store the light setup it was created for
			if ( lightsHash === undefined ) {

				materialProperties.lightsHash = lightsHash = {};

			}

			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

			if ( material.lights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, fog, material, object ) {

			textures.resetTextureUnits();

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.needsUpdate === false ) {

				if ( materialProperties.program === undefined ) {

					material.needsUpdate = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					material.needsUpdate = true;

				} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
					lightsHash.directionalLength !== lightsStateHash.directionalLength ||
					lightsHash.pointLength !== lightsStateHash.pointLength ||
					lightsHash.spotLength !== lightsStateHash.spotLength ||
					lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
					lightsHash.hemiLength !== lightsStateHash.hemiLength ||
					lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {

					material.needsUpdate = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					material.needsUpdate = true;

				}

			}

			if ( material.needsUpdate ) {

				initMaterial( material, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( material.lights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshLambertMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );

				} else if ( material.isMeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else {

						refreshUniformsPhong( m_uniforms, material );

					}

				} else if ( material.isMeshStandardMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else {

						refreshUniformsStandard( m_uniforms, material );

					}

				} else if ( material.isMeshMatcapMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					refreshUniformsMatcap( m_uniforms, material );

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshDistanceMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isSpriteMaterial ) {

					refreshUniformsSprites( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value = material.color;

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			refreshUniformsPhong( uniforms, material );

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		//

		this.setFramebuffer = function ( value ) {

			_framebuffer = value;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipMapLevel ) {

			_currentRenderTarget = renderTarget;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = _framebuffer;
			var isCube = false;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLRenderTargetCube ) {

					framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
					isCube = true;

				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipMapLevel || 0 );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( 36160, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( 36160, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {

			var width = texture.image.width;
			var height = texture.image.height;
			var glFormat = utils.convert( texture.format );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2( color, density ) {

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	Object.assign( FogExp2.prototype, {

		isFogExp2: true,

		clone: function () {

			return new FogExp2( this.color, this.density );

		},

		toJSON: function ( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog( color, near, far ) {

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	Object.assign( Fog.prototype, {

		isFog: true,

		clone: function () {

			return new Fog( this.color, this.near, this.far );

		},

		toJSON: function ( /* meta */ ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		isScene: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	function SpriteMaterial( parameters ) {

		Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.lights = false;
		this.transparent = true;

		this.setValues( parameters );

	}

	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var geometry;

	function Sprite( material ) {

		Object3D.call( this );

		this.type = 'Sprite';

		if ( geometry === undefined ) {

			geometry = new BufferGeometry();

			var float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Sprite,

		isSprite: true,

		raycast: ( function () {

			var intersectPoint = new Vector3();
			var worldScale = new Vector3();
			var mvPosition = new Vector3();

			var alignedPosition = new Vector2();
			var rotatedPosition = new Vector2();
			var viewWorldMatrix = new Matrix4();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

				// compute position in camera space
				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

				// to check if rotation is not zero
				if ( sin !== undefined ) {

					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );

				} else {

					rotatedPosition.copy( alignedPosition );

				}


				vertexPosition.copy( mvPosition );
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;

				// transform to world space
				vertexPosition.applyMatrix4( viewWorldMatrix );

			}

			return function raycast( raycaster, intersects ) {

				worldScale.setFromMatrixScale( this.matrixWorld );
				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
				mvPosition.setFromMatrixPosition( this.modelViewMatrix );

				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {

					cos = Math.cos( rotation );
					sin = Math.sin( rotation );

				}

				var center = this.center;

				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );

				uvA.set( 0, 0 );
				uvB.set( 1, 0 );
				uvC.set( 1, 1 );

				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );

				if ( intersect === null ) {

					// check second triangle
					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
					uvB.set( 0, 1 );

					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
					if ( intersect === null ) {

						return;

					}

				}

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					point: intersectPoint.clone(),
					uv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),
					face: null,
					object: this

				} );

			};

		}() ),

		clone: function () {

			return new this.constructor( this.material ).copy( this );

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			return this;

		}


	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {

		Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		},

		raycast: ( function () {

			var matrixPosition = new Vector3();

			return function raycast( raycaster, intersects ) {

				matrixPosition.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			};

		}() ),

		update: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function update( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );

					var distance = v1.distanceTo( v2 );

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh( geometry, material ) {

		if ( geometry && geometry.isGeometry ) {

			console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var vector = new Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

				vector.x = skinWeight.getX( i );
				vector.y = skinWeight.getY( i );
				vector.z = skinWeight.getZ( i );
				vector.w = skinWeight.getW( i );

				var scale = 1.0 / vector.manhattanLength();

				if ( scale !== Infinity ) {

					vector.multiplyScalar( scale );

				} else {

					vector.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.getInverse( this.matrixWorld );

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.getInverse( this.bindMatrix );

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton( bones, boneInverses ) {

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	Object.assign( Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.getInverse( this.bones[ i ].matrixWorld );

				}

				this.boneInverses.push( inverse );

			}

		},

		pose: function () {

			var bone, i, il;

			// recover the bind-time world matrices

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		},

		update: ( function () {

			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();

			return function update() {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			};

		} )(),

		clone: function () {

			return new Skeleton( this.bones, this.boneInverses );

		},

		getBoneByName: function ( name ) {

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

		}

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];

						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );

							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					lineDistances[ 0 ] = 0;

					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

					}

				}

				return this;

			};

		}() ),

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var precision = raycaster.linePrecision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += precision;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localPrecisionSq = localPrecision * localPrecision;

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > localPrecisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > localPrecisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > localPrecisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );

							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

					}

				}

				return this;

			};

		}() )

	} );

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineLoop';

	}

	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineLoop,

		isLineLoop: true,

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points( geometry, material ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();
				var intersectPoint = new Vector3();

				function testPoint( point, index ) {

					var rayPointDistanceSq = ray.distanceSqToPoint( point );

					if ( rayPointDistanceSq < localThresholdSq ) {

						ray.closestPointToPoint( point, intersectPoint );
						intersectPoint.applyMatrix4( matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

						if ( distance < raycaster.near || distance > raycaster.far ) return;

						intersects.push( {

							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						} );

					}

				}

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							position.fromArray( positions, i * 3 );

							testPoint( position, i );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.format = format !== undefined ? format : RGBFormat;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

	}

	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update: function () {

			var video = this.image;

			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry( geometry ) {

		BufferGeometry.call( this );

		this.type = 'WireframeGeometry';

		// buffer

		var vertices = [];

		// helper variables

		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			var faces = geometry.faces;

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			var position, indices, groups;
			var group, start, count;
			var index1, index2;

			vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

					group = groups[ o ];

					start = group.start;
					count = group.count;

					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( j = 0; j < 3; j ++ ) {

							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry( func, slices, stacks ) {

		Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();

	}

	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		var i, j;

		if ( func.length < 3 ) {

			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

		}

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry( vertices, indices, radius, detail ) {

		Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

		BufferGeometry.call( this );

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		var vertexBuffer = [];
		var uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( var i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			var cols = Math.pow( 2, detail );

			// we use this multidimensional array as a data structure for creating the subdivision

			var v = [];

			var i, j;

			// construct all of the vertices for this subdivision

			for ( i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );

				var rows = cols - i;

				for ( j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( i = 0; i < cols; i ++ ) {

				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function appplyRadius( radius ) {

			var vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			var vertex = new Vector3();

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];

				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			var stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			var centroid = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				var azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

		Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

		BufferGeometry.call( this );

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();

		var i, j;

		// buffer

		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( j = 0; j <= radialSegments; j ++ ) {

				var v = j / radialSegments * Math.PI * 2;

				var sin = Math.sin( v );
				var cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				for ( j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	TubeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		data.path = this.parameters.path.toJSON();

		return data;

	};

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

		BufferGeometry.call( this );

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, j;

		var vertex = new Vector3();
		var normal = new Vector3();

		var P1 = new Vector3();
		var P2 = new Vector3();

		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();

		// generate vertices, normals and uvs

		for ( i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				// indices

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		BufferGeometry.call( this );

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= radialSegments; j ++ ) {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= radialSegments; j ++ ) {

			for ( i = 1; i <= tubularSegments; i ++ ) {

				// indices

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];

			if ( ! outerNode ) return triangles;

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points

	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		var p = start, again;

		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order

		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		var stop = ear, prev, next;

		// iterate through ears, slicing them one by one

		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if ( ear === stop ) {

				// try filtering points and slicing again

				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

					// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

				return false;

			}

			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;

		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		// first look for points inside the triangle in increasing z-order

		var p = ear.nextZ;

		while ( p && p.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;

		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;

			p = p.prevZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;

		do {

			var a = p.prev, b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved

				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return p;

	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two

		var a = start;

		do {

			var b = a.next.next;

			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal

					var c = splitPolygon( a, b );

					// filter colinear points around the cuts

					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half

					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [], i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right

		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );

		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge( hole, outerNode ) {

		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

				if ( x <= hx && x > qx ) {

					qx = x;

					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;

		p = m.next;

		while ( p !== stop ) {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		}

		return m;

	}

	// interlink polygon nodes in z-order

	function indexCurve( start, minX, minY, invSize ) {

		var p = start;

		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;

				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring

	function getLeftmost( start ) {

		var p = start, leftmost = start;

		do {

			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle

	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

	}

	// signed area of a triangle

	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal

	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect

	function intersects( p1, q1, p2, q2 ) {

		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon( a, b ) {

		var p = a;

		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {

				return true;

			}

			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside( a, b ) {

		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;

		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

				inside = ! inside;

			}

			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;

		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( var i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		var l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( var i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry( shapes, options ) {

		Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	ExtrudeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry( shapes, options ) {

		BufferGeometry.call( this );

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		var scope = this;

		var verticesArray = [];
		var uvArray = [];

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			var placeholder = [];

			// options

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			var steps = options.steps !== undefined ? options.steps : 1;
			var depth = options.depth !== undefined ? options.depth : 100;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var extrudePath = options.extrudePath;

			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			var extrudePts, extrudeByPath = false;
			var splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false; // assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				var start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var start = verticesArray.length / 3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0,
						sl = steps + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	//

	var WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}
	};

	function toJSON( shapes, options, data ) {

		//

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		//

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry( text, parameters ) {

		Geometry.call( this );

		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry( text, parameters ) {

		parameters = parameters || {};

		var font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();

		}

		var shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call( this, shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			// special case for the poles

			var uOffset = ( iy == 0 ) ? 0.5 / widthSegments : ( ( iy == heightSegments ) ? - 0.5 / widthSegments : 0 );

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// some helper variables

		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= phiSegments; j ++ ) {

			for ( i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( j = 0; j < phiSegments; j ++ ) {

			var thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( i = 0; i < thetaSegments; i ++ ) {

				segment = i + thetaSegmentLevel;

				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry( points, segments, phiStart, phiLength ) {

		Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

		BufferGeometry.call( this );

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


		// buffers

		var indices = [];
		var vertices = [];
		var uvs = [];

		// helper variables

		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;

		// generate vertices and uvs

		for ( i = 0; i <= segments; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin( phi );
			var cos = Math.cos( phi );

			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

				base = j + i * points.length;

				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry( shapes, curveSegments ) {

		Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry( shapes, curveSegments ) {

		BufferGeometry.call( this );

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		curveSegments = curveSegments || 12;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var groupStart = 0;
		var groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( var i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			var i, l, shapeHole;

			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );

			var shapeVertices = points.shape;
			var shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

				var vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	//

	function toJSON$1( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry( geometry, thresholdAngle ) {

		BufferGeometry.call( this );

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		// buffer

		var vertices = [];

		// helper variables

		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];

		// prepare source geometry

		var geometry2;

		if ( geometry.isBufferGeometry ) {

			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					edges[ key ].face2 = i;

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			var e = edges[ key ];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( y = 0; y <= heightSegments; y ++ ) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row

				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				for ( y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new Vector2();
			var vertex = new Vector3();

			var groupCount = 0;

			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			var segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



	var Geometries = /*#__PURE__*/Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	function ShadowMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	ShadowMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 *  clearCoat: <float>
	 *  clearCoatRoughness: <float>
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial( parameters ) {

		MeshPhongMaterial.call( this );

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues( parameters );

	}

	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function ( source ) {

		MeshPhongMaterial.prototype.copy.call( this, source );

		this.gradientMap = source.gradientMap;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshMatcapMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshMatcapMaterial.prototype = Object.create( Material.prototype );
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	MeshMatcapMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial( parameters ) {

		LineBasicMaterial.call( this );

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function ( source ) {

		LineBasicMaterial.prototype.copy.call( this, source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};



	var Materials = /*#__PURE__*/Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Static methods

	Object.assign( KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		toJSON: function ( track ) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				var interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		}

	} );

	Object.assign( KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function ( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodLinear: function ( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: function ( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		setInterpolation: function ( interpolation ) {

			var factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return this;

			}

			this.createInterpolant = factoryMethod;

			return this;

		},

		getInterpolation: function () {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {

			if ( timeScale !== 1.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			var prevTime = null;

			for ( var i = 0; i !== nKeys; i ++ ) {

				var currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( var i = 0, n = values.length; i !== n; ++ i ) {

						var value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				writeIndex = 1,
				lastIndex = times.length - 1;

			for ( var i = 1; i < lastIndex; ++ i ) {

				var keep = false;

				var time = times[ i ];
				var timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( var j = 0; j !== stride; ++ j ) {

							var value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( var j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			}

			return this;

		},

		clone: function () {

			var times = AnimationUtils.arraySlice( this.times, 0 );
			var values = AnimationUtils.arraySlice( this.values, 0 );

			var TypedKeyframeTrack = this.constructor;
			var track = new TypedKeyframeTrack( this.name, times, values );

			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;

			return track;

		}

	} );

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack( name, times, values ) {

		KeyframeTrack.call( this, name, times, values );

	}

	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	} );

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	} );

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset = i1 * stride,

				alpha = ( t - t0 ) / ( t1 - t0 );

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear: function ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	} );

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined

	} );

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		var trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	Object.assign( AnimationClip, {

		parse: function ( json ) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

			}

			return new AnimationClip( json.name, json.duration, tracks );

		},

		toJSON: function ( clip ) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid

			};

			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		},

		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for ( var i = 0; i < numMorphTargets; i ++ ) {

				var times = [];
				var values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new AnimationClip( name, - 1, tracks );

		},

		findByName: function ( objectOrClipArray, name ) {

			var clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( var i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					var name = parts[ 1 ];

					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			var clips = [];

			for ( var name in animationToMorphTargets ) {

				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					var times = [];
					var values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

				var animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};

					for ( var k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {

						var times = [];
						var values = [];

						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							var animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					var boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			var clip = new AnimationClip( clipName, duration, tracks );

			return clip;

		}

	} );

	Object.assign( AnimationClip.prototype, {

		resetDuration: function () {

			var tracks = this.tracks, duration = 0;

			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

				var track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

			return this;

		},

		trim: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		validate: function () {

			var valid = true;

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				valid = valid && this.tracks[ i ].validate();

			}

			return valid;

		},

		optimize: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		},


		clone: function () {

			var tracks = [];

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				tracks.push( this.tracks[ i ].clone() );

			}

			return new AnimationClip( this.name, this.duration, tracks );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;
			return this;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FileLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = decodeURIComponent( data );

				if ( isBase64 ) data = atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					Cache.add( url, response );

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				request.addEventListener( 'abort', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io/
	 */

	function AnimationLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AnimationLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var clip = AnimationClip.parse( json[ i ] );

				animations.push( clip );

			}

			return animations;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( CompressedTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( DataTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( texData.image !== undefined ) {

					texture.image = texData.image;

				} else if ( texData.data !== undefined ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if ( texData.format !== undefined ) {

					texture.format = texData.format;

				}
				if ( texData.type !== undefined ) {

					texture.type = texData.type;

				}

				if ( texData.mipmaps !== undefined ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( texData.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function ImageLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( ImageLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function CubeTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( CubeTextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function TextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( TextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = /*#__PURE__*/Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light( color, intensity ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.matrix = new Matrix4();

	}

	Object.assign( LightShadow.prototype, {

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {

		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	}

	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update: function ( light ) {

			var camera = this.camera;

			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

		Light.call( this, color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: SpotLight,

		isSpotLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight( color, intensity, distance, decay ) {

		Light.call( this, color, intensity );

		this.type = 'PointLight';

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / ( 4 * Math.PI );

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	}

	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: PointLight,

		isPointLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = ( left !== undefined ) ? left : - 1;
		this.right = ( right !== undefined ) ? right : 1;
		this.top = ( top !== undefined ) ? top : 1;
		this.bottom = ( bottom !== undefined ) ? bottom : - 1;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;

				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow( ) {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight( color, intensity, width, height ) {

		Light.call( this, color, intensity );

		this.type = 'RectAreaLight';

		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;

	}

	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};

	}

	Object.assign( MaterialLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			var material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.combine !== undefined ) material.combine = json.combine;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;

			// Shader Material

			if ( json.uniforms !== undefined ) {

				for ( var name in json.uniforms ) {

					var uniform = json.uniforms[ name ];

					material.uniforms[ name ] = {};

					switch ( uniform.type ) {

						case 't':
							material.uniforms[ name ].value = getTexture( uniform.value );
							break;

						case 'c':
							material.uniforms[ name ].value = new Color().setHex( uniform.value );
							break;

						case 'v2':
							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
							break;

						case 'v3':
							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
							break;

						case 'v4':
							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
							break;

						case 'm3':
							material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

						case 'm4':
							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
							break;

						default:
							material.uniforms[ name ].value = uniform.value;

					}

				}

			}

			if ( json.defines !== undefined ) material.defines = json.defines;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

			if ( json.extensions !== undefined ) {

				for ( var key in json.extensions ) {

					material.extensions[ key ] = json.extensions[ key ];

				}

			}

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {

				var normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			return material;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setTextures: function ( value ) {

			this.textures = value;
			return this;

		}

	} );

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );

		},

		extractUrlBase: function ( url ) {

			var index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.substr( 0, index + 1 );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( BufferGeometryLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var geometry = new BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

				var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
				if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
				geometry.addAttribute( key, bufferAttribute );

			}

			var morphAttributes = json.data.morphAttributes;

			if ( morphAttributes ) {

				for ( var key in morphAttributes ) {

					var attributeArray = morphAttributes[ key ];

					var array = [];

					for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

						var attribute = attributeArray[ i ];
						var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

						var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
						if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
						array.push( bufferAttribute );

					}

					geometry.morphAttributes[ key ] = array;

				}

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			if ( json.name ) geometry.name = json.name;
			if ( json.userData ) geometry.userData = json.userData;

			return geometry;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.resourcePath = '';

	}

	Object.assign( ObjectLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;
			this.resourcePath = this.resourcePath || path;

			var loader = new FileLoader( scope.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				var metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResourcePath: function ( value ) {

			this.resourcePath = value;
			return this;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		parse: function ( json, onLoad ) {

			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseShape: function ( json ) {

			var shapes = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		},

		parseGeometries: function ( json, shapes ) {

			var geometries = {};

			if ( json !== undefined ) {

				var bufferGeometryLoader = new BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'TubeGeometry':
						case 'TubeBufferGeometry':

							// This only works for built-in curves (e.g. CatmullRomCurve3).
							// User defined curves or instances of CurvePath will not be deserialized.
							geometry = new Geometries[ data.type ](
								new Curves[ data.path.type ]().fromJSON( data.path ),
								data.tubularSegments,
								data.radius,
								data.radialSegments,
								data.closed
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;


						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							var extrudePath = data.options.extrudePath;

							if ( extrudePath !== undefined ) {

								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {

								var geometryLoader = new THREE.LegacyJSONLoader();
								geometry = geometryLoader.parse( data, this.resourcePath ).geometry;


							} else {

								console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".' );

							}

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var cache = {}; // MultiMaterial
			var materials = {};

			if ( json !== undefined ) {

				var loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						var array = [];

						for ( var j = 0; j < data.materials.length; j ++ ) {

							var material = data.materials[ j ];

							if ( cache[ material.uuid ] === undefined ) {

								cache[ material.uuid ] = loader.parse( material );

							}

							array.push( cache[ material.uuid ] );

						}

						materials[ data.uuid ] = array;

					} else {

						if ( cache[ data.uuid ] === undefined ) {

							cache[ data.uuid ] = loader.parse( data );

						}

						materials[ data.uuid ] = cache[ data.uuid ];

					}

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var data = json[ i ];

				var clip = AnimationClip.parse( data );

				if ( data.uuid !== undefined ) clip.uuid = data.uuid;

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new LoadingManager( onLoad );

				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, il = json.length; i < il; i ++ ) {

					var image = json[ i ];
					var url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						images[ image.uuid ] = [];

						for ( var j = 0, jl = url.length; j < jl; j ++ ) {

							var currentUrl = url[ j ];

							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

							images[ image.uuid ].push( loadImage( path ) );

						}

					} else {

						// load single image

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture;

					if ( Array.isArray( images[ data.image ] ) ) {

						texture = new CubeTexture( images[ data.image ] );

					} else {

						texture = new Texture( images[ data.image ] );

					}

					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.format !== undefined ) texture.format = data.format;
					if ( data.type !== undefined ) texture.type = data.type;
					if ( data.encoding !== undefined ) texture.encoding = data.encoding;

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
					if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					var array = [];

					for ( var i = 0, l = name.length; i < l; i ++ ) {

						var uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;

			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );

				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;

			if ( data.children !== undefined ) {

				var children = data.children;

				for ( var i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	} );

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */


	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;

	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				if ( scope.options === undefined ) {

					// Workaround for FireFox. It causes an error if you pass options.
					return createImageBitmap( blob );

				} else {

					return createImageBitmap( blob, scope.options );

				}

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

			scope.manager.itemStart( url );

		},

		setCrossOrigin: function ( /* value */ ) {

			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */


	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size ) {

			if ( size === undefined ) size = 100;

			var shapes = [];
			var paths = createPaths( text, size, this.data );

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	function createPaths( text, size, data ) {

		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

		var paths = [];

		var offsetX = 0, offsetY = 0;

		for ( var i = 0; i < chars.length; i ++ ) {

			var char = chars[ i ];

			if ( char === '\n' ) {

				offsetX = 0;
				offsetY -= line_height;

			} else {

				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );

			}

		}

		return paths;

	}

	function createPath( char, scale, offsetX, offsetY, data ) {

		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

		if ( ! glyph ) return;

		var path = new ShapePath();

		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if ( glyph.o ) {

			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

			for ( var i = 0, l = outline.length; i < l; ) {

				var action = outline[ i ++ ];

				switch ( action ) {

					case 'm': // moveTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.moveTo( x, y );

						break;

					case 'l': // lineTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.lineTo( x, y );

						break;

					case 'q': // quadraticCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						break;

					case 'b': // bezierCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						break;

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FontLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json;

				try {

					json = JSON.parse( text );

				} catch ( e ) {

					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );

				}

				var font = scope.parse( json );

				if ( onLoad ) onLoad( font );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			return new Font( json );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {}

	Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	Object.assign( Loader.prototype, {

		crossOrigin: 'anonymous',

		onLoadStart: function () {},

		onLoadProgress: function () {},

		onLoadComplete: function () {},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};

			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();

			return function createMaterial( m, texturePath, crossOrigin ) {

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = _Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {

						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = value;
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;

					}

				}

				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var context;

	var AudioContext = {

		getContext: function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AudioLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.load( url, function ( buffer ) {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );

				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			}, onProgress, onError );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

	}

	Object.assign( StereoCamera.prototype, {

		update: ( function () {

			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();

			return function update( camera ) {

				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

			};

		} )()

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera( near, far, cubeResolution, options ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var currentRenderTarget = renderer.getRenderTarget();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var currentRenderTarget = renderer.getRenderTarget();

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( renderTarget, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

			return this;

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

			return this;

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();
			var clock = new Clock();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.timeDelta = clock.getDelta();

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

				if ( listener.positionX ) {

					// code path for Chrome (see #14393)

					var endTime = this.context.currentTime + this.timeDelta;

					listener.positionX.linearRampToValueAtTime( position.x, endTime );
					listener.positionY.linearRampToValueAtTime( position.y, endTime );
					listener.positionZ.linearRampToValueAtTime( position.z, endTime );
					listener.forwardX.linearRampToValueAtTime( orientation.x, endTime );
					listener.forwardY.linearRampToValueAtTime( orientation.y, endTime );
					listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );
					listener.upX.linearRampToValueAtTime( up.x, endTime );
					listener.upY.linearRampToValueAtTime( up.y, endTime );
					listener.upZ.linearRampToValueAtTime( up.z, endTime );

				} else {

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setMediaElementSource: function ( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function () {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );

			this.isPlaying = true;

			this.source = source;

			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this.source.stop();
				this.source.onended = null;
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.source.onended = null;
			this.offset = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		setDetune: function ( value ) {

			this.detune = value;

			if ( this.source.detune === undefined ) return; // only set detune when available

			if ( this.isPlaying === true ) {

				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

			}

			return this;

		},

		getDetune: function () {

			return this.detune;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

			return this;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

			return this;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

			return this;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

			return this;

		},

		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );

				var panner = this.panner;

				if ( panner.positionX ) {

					// code path for Chrome and Firefox (see #14393)

					var endTime = this.context.currentTime + this.listener.timeDelta;

					panner.positionX.linearRampToValueAtTime( position.x, endTime );
					panner.positionY.linearRampToValueAtTime( position.y, endTime );
					panner.positionZ.linearRampToValueAtTime( position.z, endTime );
					panner.orientationX.linearRampToValueAtTime( orientation.x, endTime );
					panner.orientationY.linearRampToValueAtTime( orientation.y, endTime );
					panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );

				} else {

					panner.setPosition( position.x, position.y, position.z );
					panner.setOrientation( orientation.x, orientation.y, orientation.z );

				}

			};

		} )()


	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				break;

			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;

			default:
				mixFunction = this._lerp;

		}

		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	Object.assign( PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		},


		// mix functions

		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		},

		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		},

		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

			var s = 1 - t;

			for ( var i = 0; i !== stride; ++ i ) {

				var j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

	} );

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {

			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

			return function sanitizeNodeName( name ) {

				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

			};

		}() ),

		parseTrackName: function () {

			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);

			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

			return function parseTrackName( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

		}(),

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {

		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	Object.assign( AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function () {

			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function ( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		},

		unsubscribe_: function ( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	} );

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction( mixer, clip, localRoot ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( var i = 0; i !== nTracks; ++ i ) {

			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	Object.assign( AnimationAction.prototype, {

		// State & Scheduling

		play: function () {

			this._mixer._activateAction( this );

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction( this );

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0; // restart clip
			this._loopCount = - 1;// forget previous loops
			this._startTime = null;// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction( this );

		},

		startAt: function ( time ) {

			this._startTime = time;

			return this;

		},

		setLoop: function ( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function ( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		},

		fadeOut: function ( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		},

		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		},

		crossFadeTo: function ( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function ( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function ( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function ( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		},

		warp: function ( startTimeScale, endTimeScale, duration ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			var startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight( time );

			if ( weight > 0 ) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );

				}

			}

		},

		_updateWeight: function ( time ) {

			var weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function ( time ) {

			var timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function ( deltaTime ) {

			var time = this.time + deltaTime;
			var duration = this._clip.duration;
			var loop = this.loop;
			var loopCount = this._loopCount;

			var pingPong = ( loop === LoopPingPong );

			if ( deltaTime === 0 ) {

				if ( loopCount === - 1 ) return time;

				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

			}

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else break handle_stop;

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function ( atStart, atEnd, pingPong ) {

			var settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function ( duration, weightNow, weightThen ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;
			values[ 1 ] = weightThen;

			return this;

		}

	} );

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer( root ) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	}

	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: AnimationMixer,

		_bindAction: function ( action, prototypeAction ) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( var i = 0; i !== nTracks; ++ i ) {

				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function ( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		},

		_deactivateAction: function ( action ) {

			if ( this._isActiveAction( action ) ) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		},

		// Memory management for AnimationAction objects

		_isActiveAction: function ( action ) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		},

		_removeInactiveAction: function ( action ) {

			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		},

		_removeInactiveBindingsForAction: function ( action ) {

			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		},

		_lendAction: function ( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		},

		_takeBackAction: function ( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				bindings = this._bindings;

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		},

		_removeInactiveBinding: function ( binding ) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			remove_empty_map: {

				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[ rootUuid ];

			}

		},

		_lendBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		},

		_takeBackBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function ( interpolant ) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;

			if ( actionsForClip !== undefined ) {

				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		},

		// get an existing action
		existingAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for ( var i = 0; i !== nActions; ++ i ) {

				actions[ i ].reset();

			}

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function ( deltaTime ) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( var i = 0; i !== nActions; ++ i ) {

				var action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					var action = actionsToRemove[ i ];

					this._deactivateAction( action );

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( var clipUuid in actionsByClip ) {

				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( var trackName in bindingByName ) {

					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {

			var action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

		if ( typeof ( normalized ) === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		BufferAttribute.call( this, array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( ( camera && camera.isPerspectiveCamera ) ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( ( camera && camera.isOrthographicCamera ) ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axiz.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
		this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		},

		setFromCartesianCoords: function ( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	Object.assign( Cylindrical.prototype, {

		set: function ( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		},

		setFromVector3: function ( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		},

		setFromCartesianCoords: function ( x, y, z ) {

			this.radius = Math.sqrt( x * x + z * z );
			this.theta = Math.atan2( x, z );
			this.y = y;

			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	Object.assign( Box2.prototype, {

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector2();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		intersectsBox: function ( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		},

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector2();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	Object.assign( Line3.prototype, {

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();

			}

			return target.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new Vector3();
			var startEnd = new Vector3();

			return function closestPointToPointParameter( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = _Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, target ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	}

	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new BufferGeometry();

		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	SpotLightHelper.prototype.update = function () {

		var vector = new Vector3();

		return function update() {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

	}();

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList( object ) {

		var boneList = [];

		if ( object && object.isBone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	function SkeletonHelper( object ) {

		var bones = getBoneList( object );

		var geometry = new BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		LineSegments.call( this, geometry, material );

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = function () {

		var vector = new Vector3();

		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();

		return function updateMatrixWorld( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper( light, sphereSize, color ) {

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

		Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	}

	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	PointLightHelper.prototype.update = function () {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 *  This helper must be added as a child of the light
	 */

	function RectAreaLightHelper( light, color ) {

		this.type = 'RectAreaLightHelper';

		this.light = light;

		this.color = color; // optional hardwired color for the helper

		var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		var material = new LineBasicMaterial( { fog: false } );

		Line.call( this, geometry, material );

		//

		var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );

		this.update();

	}

	RectAreaLightHelper.prototype = Object.create( Line.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.update = function () {

		this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );
			this.children[ 0 ].material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			// prevent hue shift
			var c = this.material.color;
			var max = Math.max( c.r, c.g, c.b );
			if ( max > 1 ) c.multiplyScalar( 1 / max );

			this.children[ 0 ].material.color.copy( this.material.color );

		}

	};

	RectAreaLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );

		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	HemisphereLightHelper.prototype.update = function () {

		var vector = new Vector3();

		var color1 = new Color();
		var color2 = new Color();

		return function update() {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper( size, divisions, color1, color2 ) {

		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;

		var vertices = [], colors = [];

		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			var color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

		constructor: GridHelper,

		copy: function ( source ) {

			LineSegments.prototype.copy.call( this, source );

			this.geometry.copy( source.geometry );
			this.material.copy( source.material );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var vertices = [];
		var colors = [];

		var x, z;
		var v, i, j, r, color;

		// create the radials

		for ( i = 0; i <= radials; i ++ ) {

			v = ( i / radials ) * ( Math.PI * 2 );

			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( i = 0; i <= circles; i ++ ) {

			color = ( i & 1 ) ? color1 : color2;

			r = radius - ( radius / circles * i );

			for ( j = 0; j < divisions; j ++ ) {

				// first vertex

				v = ( j / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function PositionalAudioHelper( audio, range, divisionsInnerAngle, divisionsOuterAngle ) {

		this.audio = audio;
		this.range = range || 1;
		this.divisionsInnerAngle = divisionsInnerAngle || 16;
		this.divisionsOuterAngle = divisionsOuterAngle || 2;

		var geometry = new BufferGeometry();
		var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
		var positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		var materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );
		var materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );

		Line.call( this, geometry, [ materialOuterAngle, materialInnerAngle ] );

		this.update();

	}

	PositionalAudioHelper.prototype = Object.create( Line.prototype );
	PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;

	PositionalAudioHelper.prototype.update = function () {

		var audio = this.audio;
		var range = this.range;
		var divisionsInnerAngle = this.divisionsInnerAngle;
		var divisionsOuterAngle = this.divisionsOuterAngle;

		var coneInnerAngle = _Math.degToRad( audio.panner.coneInnerAngle );
		var coneOuterAngle = _Math.degToRad( audio.panner.coneOuterAngle );

		var halfConeInnerAngle = coneInnerAngle / 2;
		var halfConeOuterAngle = coneOuterAngle / 2;

		var start = 0;
		var count = 0;
		var i, stride;

		var geometry = this.geometry;
		var positionAttribute = geometry.attributes.position;

		geometry.clearGroups();

		//

		function generateSegment( from, to, divisions, materialIndex ) {

			var step = ( to - from ) / divisions;

			positionAttribute.setXYZ( start, 0, 0, 0 );
			count ++;

			for ( i = from; i < to; i += step ) {

				stride = start + count;

				positionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );
				positionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );
				positionAttribute.setXYZ( stride + 2, 0, 0, 0 );

				count += 3;

			}

			geometry.addGroup( start, count, materialIndex );

			start += count;
			count = 0;

		}

		//

		generateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );
		generateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );
		generateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );

		//

		positionAttribute.needsUpdate = true;

		if ( coneInnerAngle === coneOuterAngle ) this.material[ 0 ].visible = false;

	};

	PositionalAudioHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material[ 0 ].dispose();
		this.material[ 1 ].dispose();

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	}

	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	DirectionalLightHelper.prototype.update = function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();

		return function update() {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v2 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( v2 );
			this.targetLine.scale.z = v3.length();

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper( camera ) {

		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

		var vertices = [];
		var colors = [];

		var pointMap = {};

		// colors

		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		LineSegments.call( this, geometry, material );

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new Vector3();
		var camera = new Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix inverse
			// world matrix must be identity

			camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

			// center / target

			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );

			// near

			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );

			// far

			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );

			// up

			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );

			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper( object, color ) {

		this.object = object;

		if ( color === undefined ) color = 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.matrixAutoUpdate = false;

		this.update();

	}

	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = ( function () {

		var box = new Box3();

		return function update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				box.setFromObject( this.object );

			}

			if ( box.isEmpty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	} )();

	BoxHelper.prototype.setFromObject = function ( object ) {

		this.object = object;
		this.update();

		return this;

	};

	BoxHelper.prototype.copy = function ( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	};

	BoxHelper.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper( box, hex ) {

		this.type = 'Box3Helper';

		this.box = box;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		var geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.geometry.computeBoundingSphere();

	}

	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

		var box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper( plane, size, hex ) {

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = ( size === undefined ) ? 1 : size;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		//

		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

	}

	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

		var scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	var lineGeometry, coneGeometry;

	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		Object3D.call( this );

		if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
		if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
		if ( length === undefined ) length = 1;
		if ( color === undefined ) color = 0xffff00;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( lineGeometry === undefined ) {

			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = ( function () {

		var axis = new Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );

	};

	ArrowHelper.prototype.copy = function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	};

	ArrowHelper.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper( size ) {

		size = size || 1;

		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;

	var LinePieces = 1;

	function MeshFaceMaterial( materials ) {

		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;

	}

	function MultiMaterial( materials ) {

		if ( materials === undefined ) materials = [];

		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {

			return materials.slice();

		};
		return materials;

	}

	function PointCloud( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function Particle( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );

	}

	function ParticleSystem( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function PointCloudMaterial( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleBasicMaterial( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleSystemMaterial( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function Vertex( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );

	}

	//

	function DynamicBufferAttribute( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );

	}

	function Int8Attribute( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );

	}

	function Uint8Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );

	}

	function Uint8ClampedAttribute( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );

	}

	function Int16Attribute( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );

	}

	function Uint16Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );

	}

	function Int32Attribute( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );

	}

	function Uint32Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );

	}

	function Float32Attribute( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );

	}

	function Float64Attribute( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	//

	function AxisHelper( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );

	}

	function BoundingBoxHelper( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );

	}

	function EdgesHelper( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	function WireframeHelper( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	function XHRLoader( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );

	}

	function BinaryTextureLoader( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );

	}

	Object.assign( ObjectLoader.prototype, {

		setTexturePath: function ( value ) {

			console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
			return this.setResourcePath( value );

		}

	} );

	//

	Object.assign( Box2.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Line3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Object.assign( _Math, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			var v1;

			return function getPosition() {

				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );

			};

		}(),
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Ray.prototype, {

		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionPlane: function ( plane ) {

			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		}

	} );

	Object.assign( Triangle.prototype, {

		area: function () {

			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();

		},
		barycoordFromPoint: function ( point, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );

		},
		midpoint: function ( target ) {

			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );

		},
		normal: function ( target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );

		},
		plane: function ( target ) {

			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );

		}

	} );

	Object.assign( Triangle, {

		barycoordFromPoint: function ( point, a, b, c, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );

		},
		normal: function ( a, b, c, target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Object.assign( Geometry.prototype, {

		computeTangents: function () {

			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

		},
		computeLineDistances: function () {

			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

		}

	} );

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},
		getWorldRotation: function () {

			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	SkinnedMesh.prototype.initBones = function () {

		console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

	};

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		copyIndicesArray: function ( /* indices */ ) {

			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

		}

	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	//

	Object.assign( ExtrudeBufferGeometry.prototype, {

		getArrays: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

		},

		addShapeList: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

		},

		addShape: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

		}

	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},

		overdraw: {
			get: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			}
		},

		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		clearTarget: function ( renderTarget, color, depth, stencil ) {

			console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		},
		animate: function ( callback ) {

			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );

		},
		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},
		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},
		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},
		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},
		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		},
		setFaceCulling: function () {

			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

		},
		allocTextureUnit: function () {

			console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

		},
		setTexture: function () {

			console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

		},
		setTexture2D: function () {

			console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

		},
		setTextureCube: function () {

			console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTargetCube.prototype, {

		activeCubeFace: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().' );

			}
		},
		activeMipMapLevel: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.defineProperties( WebVRManager.prototype, {

		standing: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

			}
		},
		userHeight: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .userHeight has been removed.' );

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadCompressedTexture = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	};

	ImageUtils.loadCompressedTextureCube = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	};

	//

	function Projector() {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function () {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	}

	//

	function CanvasRenderer() {

		console.error( 'THREE.CanvasRenderer has been removed' );

	}

	//

	function JSONLoader() {

		console.error( 'THREE.JSONLoader has been removed.' );

	}

	//

	var SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		detach: function ( /* child, parent, scene */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		attach: function ( /* child, scene, parent */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		}

	};

	//

	function LensFlare() {

		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );

	}

	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.AnimationLoader = AnimationLoader;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PositionalAudioHelper = PositionalAudioHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ImageUtils = ImageUtils;
	exports.ShapeUtils = ShapeUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.CubeGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RedFormat = RedFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;
	exports.JSONLoader = JSONLoader;
	exports.SceneUtils = SceneUtils;
	exports.LensFlare = LensFlare;

	Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}]},{},[2]);
